# xiaochengxu
# QUESTION：说说你对微信小程序的理解？优缺点？

 ![](https://static.vue-js.com/be367c80-300e-11ec-8e64-91fdec0f05a1.png)

## 一、是什么

2017年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务

截至目前，小程序已经成为国内前端的一个重要业务，跟 `Web` 和手机 `App` 有着同等的重要性

 ![](https://static.vue-js.com/ce751de0-300e-11ec-8e64-91fdec0f05a1.png)

小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用

也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载

注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序



## 二、背景

⼩程序并⾮凭空冒出来的⼀个概念，当微信中的 `WebView` 逐渐成为移动 `Web`的⼀个重要⼊⼝时，微信就有相关的 `JS-SDK`

`JS-SDK` 解决了移动⽹⻚能⼒不⾜的问题，通过暴露微信的接⼝使得 `Web` 开发者能够拥有更多的能⼒，然⽽在更多的能⼒之外，`JS-SDK`的模式并没有解决使⽤移动⽹⻚遇到的体验不良的问题

因此需要设计⼀个⽐较好的系统，使得所有开发者在微信中都能获得⽐较好的体验：
- 快速的加载
- 更强⼤的能⼒
- 原⽣的体验
- 易⽤且安全的微信数据开放
- ⾼效和简单的开发

这些是`JS-SDK`做不到的，需要设计一个全新的小程序系统

对于小程序的开发，提供一个简单、高效的应用开发框架和丰富的组件及`API`，帮助开发者开发出具有原生体验的服务

其中相比`H5`，小程序与其的区别有如下：
- 运⾏环境：⼩程序基于浏览器内核重构的内置解析器
- 系统权限：⼩程序能获得更多的系统权限，如⽹络通信状态、数据缓存能⼒等
- 渲染机制：⼩程序的逻辑层和渲染层是分开的

小程序可以视为只能用微信打开和浏览的`H5`，小程序和网页的技术模型是一样的，用到的 `JavaScript` 语言和 `CSS` 样式也是一样的，只是网页的 `HTML` 标签被稍微修改成了 `WXML` 标签

因此可以说，小程序页面本质上就是网页

其中关于微信小程序的实现原理，我们在后面的文章讲到



## 三、优缺点

优点：
- 随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体
- 流量大，易接受：小程序借助自身平台更加容易引入更多的流量
- 安全
- 开发门槛低
- 降低兼容性限制



缺点：

- 用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%
- 体积限制：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序
- 受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的限制，从功能接口，甚至到类别内容，都要接受微信的管控



## 参考文献

- https://developers.weixin.qq.com/miniprogram/dev/framework/
- https://www.zhihu.com/question/263816362

# QUESTION：说说微信小程序的生命周期函数有哪些？



 ![](https://static.vue-js.com/1df64890-30e0-11ec-8e64-91fdec0f05a1.png)


## 一、是什么

跟`vue`、`react`框架一样，微信小程序框架也存在生命周期，实质也是一堆会在特定时期执行的函数

小程序中，生命周期主要分成了三部分：

- 应用的生命周期
- 页面的生命周期
- 组件的生命周期

### 应用的生命周期

小程序的生命周期函数是在`app.js`里面调用的，通过`App(Object)`函数用来注册一个小程序，指定其小程序的生命周期回调



### 页面的生命周期

页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数，同样通过`App(Object)`函数用来注册一个页面



### 组件的生命周期

组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过`Component(Object)`进行注册组件





## 二、有哪些

### 应用的生命周期

| 生命周期               | 说明                                    |
| ---------------------- | --------------------------------------- |
| onLaunch               | 小程序初始化完成时触发，全局只触发一次  |
| onShow                 | 小程序启动，或从后台进入前台显示时触发  |
| onHide                 | 小程序从前台进入后台时触发              |
| onError                | 小程序发生脚本错误或 API 调用报错时触发 |
| onPageNotFound         | 小程序要打开的页面不存在时触发          |
| onUnhandledRejection() | 小程序有未处理的 Promise 拒绝时触发     |
| onThemeChange          | 系统切换主题时触发                      |







### 页面的生命周期

| 生命周期 | 说明                              | 作用                           |
| -------- | --------------------------------- | ------------------------------ |
| onLoad   | 生命周期回调—监听页面加载         | 发送请求获取数据               |
| onShow   | 生命周期回调—监听页面显示         | 请求数据                       |
| onReady  | 生命周期回调—监听页面初次渲染完成 | 获取页面元素（少用）           |
| onHide   | 生命周期回调—监听页面隐藏         | 终止任务，如定时器或者播放音乐 |
| onUnload | 生命周期回调—监听页面卸载         | 终止任务                       |





### 组件的生命周期

| 生命周期 | 说明                              |
| -------- | --------------------------------- |
| created  | 生命周期回调—监听页面加载         |
| attached | 生命周期回调—监听页面显示         |
| ready    | 生命周期回调—监听页面初次渲染完成 |
| moved    | 生命周期回调—监听页面隐藏         |
| detached | 生命周期回调—监听页面卸载         |
| error    | 每当组件方法抛出错误时执行        |

注意的是：

- 组件实例刚刚被创建好时， created 生命周期被触发，此时，组件数据 this.data 就是在 Component  构造器中定义的数据 data ， 此时不能调用 setData
- 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行
- 在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则  detached 会被触发

还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理，这样的生命周期称为“组件所在页面的生命周期”，在 `pageLifetimes` 定义段中定义，如下：

| 生命周期 | 说明                       |
| -------- | -------------------------- |
| show     | 组件所在的页面被展示时执行 |
| hide     | 组件所在的页面被隐藏时执行 |

代码如下：

```js
Component({
  pageLifetimes: {
    show: function() {
      // 页面被展示
    },
    hide: function() {
      // 页面被隐藏
    },
  }
})
```






## 三、执行过程

### 应⽤的⽣命周期执行过程：

-  ⽤户⾸次打开⼩程序，触发 onLaunch（全局只触发⼀次）

-  ⼩程序初始化完成后，触发onShow⽅法，监听⼩程序显示

-  ⼩程序从前台进⼊后台，触发 onHide⽅法

-  ⼩程序从后台进⼊前台显示，触发 onShow⽅法

-  ⼩程序后台运⾏⼀定时间，或系统资源占⽤过⾼，会被销毁



### ⻚⾯⽣命周期的执行过程：

- ⼩程序注册完成后，加载⻚⾯，触发onLoad⽅法
- ⻚⾯载⼊后触发onShow⽅法，显示⻚⾯
- ⾸次显示⻚⾯，会触发onReady⽅法，渲染⻚⾯元素和样式，⼀个⻚⾯只会调⽤⼀次
- 当⼩程序后台运⾏或跳转到其他⻚⾯时，触发onHide⽅法
- 当⼩程序有后台进⼊到前台运⾏或重新进⼊⻚⾯时，触发onShow⽅法
- 当使⽤重定向⽅法 wx.redirectTo() 或关闭当前⻚返回上⼀⻚wx.navigateBack()，触发onUnload



当存在也应用生命周期和页面周期的时候，相关的执行顺序如下：

- 打开小程序：(App)onLaunch --> (App)onShow --> (Pages)onLoad --> (Pages)onShow --> (pages)onRead

- 进入下一个页面：(Pages)onHide --> (Next)onLoad --> (Next)onShow --> (Next)onReady

- 返回上一个页面：(curr)onUnload --> (pre)onShow

- 离开小程序：(App)onHide

- 再次进入：小程序未销毁 --> (App)onShow(执行上面的顺序），小程序被销毁，（App)onLaunch重新开始执行.



## 参考文献

- https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object
- https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query
- https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object


# QUESTION：说说微信小程序中路由跳转的方式有哪些？区别？



 ![](https://static.vue-js.com/52bd3820-31a5-11ec-8e64-91fdec0f05a1.png)



## 一、是什么

微信小程序拥有`web`网页和`Application`共同的特征，我们的页面都不是孤立存在的，而是通过和其他页面进行交互，来共同完成系统的功能

在微信小程序中，每个页面可以看成是一个` pageModel`，`pageModel `全部以栈的形式进行管理



## 二、有哪些

常见的微信小程序页面跳转方式有如下：

- wx.navigateTo(Object)
- wx.redirectTo(Object)
- wx.switchTab(Object)
- wx.navigateBack(Object)
- wx.reLaunch(Object)



### wx.navigateTo(Object)

`wx.navigateTo()`用于保留当前页面、跳转到应用内的某个页面，使用 `wx.navigateBack`可以返回到原页面

对于页面不是特别多的小程序，通常推荐使用 `wx.navigateTo`进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用

参数表如下所示：

 ![](https://static.vue-js.com/5e524ea0-31a5-11ec-8e64-91fdec0f05a1.png)

流程图如下：

 ![](https://static.vue-js.com/68f033e0-31a5-11ec-8e64-91fdec0f05a1.png)



### wx.redirectTo(Object)

重定向，当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 10 层页面栈的情况下，我们应该考虑选择 `wx.redirectTo`

`wx.redirectTo()`用于关闭当前页面，跳转到应用内的某个页面

这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间

参数表如下所示：

 ![](https://static.vue-js.com/76066c20-31a5-11ec-8e64-91fdec0f05a1.png)

流程图如下所示：

 ![](https://static.vue-js.com/828c4b40-31a5-11ec-a752-75723a64e8f5.png)



### wx.switchTab(Object)

跳转到 `tabBar `页面，并关闭其他所有非 `tabBar` 页面

参数表如下所示：

 ![](https://static.vue-js.com/968869d0-31a5-11ec-a752-75723a64e8f5.png)



### wx.navigateBack(Object)

`wx.navigateBack()` 用于关闭当前页面，并返回上一页面或多级页面，开发者可通过 `getCurrentPages()` 获取当前的页面栈，决定需要返回几层则设置对象的`delta`属性即可

参数表如下：

 ![](https://static.vue-js.com/a28d8030-31a5-11ec-a752-75723a64e8f5.png)



### wx.reLaunch(Object)

关闭所有页面，打开到应用内的某个页面，返回的时候跳到首页

流程图如下所示：

 ![](https://static.vue-js.com/accca3a0-31a5-11ec-8e64-91fdec0f05a1.png)

参数表如下所示：

 ![](https://static.vue-js.com/b98c7e80-31a5-11ec-8e64-91fdec0f05a1.png)







## 三、总结

关于上述五种跳转方式，做下总结：

- navigateTo 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页
- redirectTo 关闭当前页面，跳转到应用内的某个页面
- switchTab 跳转到 tabBar 页面，同时关闭其他非 tabBar 页面
- navigateBack 返回上一页面
- reLanch 关闭所有页面，打开到应用内的某个页面

其中关于它们的页面栈的关系如下：

- avigateTo 新页面入栈

- redirectTo 当前页面出栈，新页面入栈
- navigateBack 页面不断出栈，直到目标返回页，新页面入栈
- switchTab 页面全部出栈，只留下新的 Tab 页面
- reLanch 页面全部出栈，只留下新的页面



## 参考文献

- https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html


# QUESTION：说说提高微信小程序的应用速度的手段有哪些？

 ![](https://static.vue-js.com/f606d530-3278-11ec-a752-75723a64e8f5.png)



## 一、是什么

小程序启动会常常遇到如下图场景：

 ![](https://static.vue-js.com/03941230-3279-11ec-8e64-91fdec0f05a1.png)

这是因为，小程序首次启动前，微信会在小程序启动前为小程序准备好通用的运行环境，如运行中的线程和一些基础库的初始化

然后才开始进入启动状态，展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：

- 下载小程序代码包
- 加载小程序代码包
- 初始化小程序首页

下载到的小程序代码包不是小程序的源代码，而是编译、压缩、打包之后的代码包

整体流程如下图：

 ![](https://static.vue-js.com/11c0ea90-3279-11ec-a752-75723a64e8f5.png)





## 二、手段

围绕上图小程序的启动流程， 我们可以从加载、渲染两个纬度进行切入：



### 加载

提升体验最直接的方法是控制小程序包的大小，常见手段有如下：

- 代码包的体积压缩可以通过勾选开发者工具中“上传代码时，压缩代码”选项

- 及时清理无用的代码和资源文件
- 减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限

并且可以采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载

当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包

 ![](https://static.vue-js.com/2034de10-3279-11ec-8e64-91fdec0f05a1.png)



### 渲染

关于微信小程序首屏渲染优化的手段如下：

- 请求可以在页面onLoad就加载，不需要等页面ready后在异步请求数据
- 尽量减少不必要的https请求，可使用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地
- 可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--> 详情页），没有数据的模块可以进行骨架屏的占位



在微信小程序中，提高页面的多次渲染效率主要在于正确使用`setData`：

- 不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用
- 数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用`setData`来设置这些数据
- 与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下



除此之外，对于一些独立的模块我们尽可能抽离出来，这是因为自定义组件的更新并不会影响页面上其他元素的更新

各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、`setData`调用









## 三、总结

**小程序启动加载性能**：

- 控制代码包的大小
- 分包加载
- 首屏体验（预请求，利用缓存，避免白屏，及时反馈

**小程序渲染性能**：

- 避免不当的使用setData
- 使用自定义组件



### 参考文献

- https://juejin.cn/post/6969779451177484296
- https://segmentfault.com/a/1190000008925450
- https://juejin.cn/post/6844903638226173965
- https://juejin.cn/post/6844903726939897869


# QUESTION：说说微信小程序的登录流程？



 ![](https://static.vue-js.com/aa3ccbd0-3428-11ec-8e64-91fdec0f05a1.png)


## 一、背景

传统的`web`开发实现登陆功能，一般的做法是输入账号密码、或者输入手机号及短信验证码进行登录

服务端校验用户信息通过之后，下发一个代表登录态的 `token` 给客户端，以便进行后续的交互,每当`token`过期，用户都需要重新登录

而在微信小程序中，可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系，从而实现登陆功能

实现小程序用户体系主要涉及到`openid`和`code`的概念：

- 调用`wx.login()`方法会生成`code`，将`code`作为参数传递给微信服务器指定接口，就可以获取用户的`openid`

对于每个小程序，微信都会将用户的微信`ID`映射出一个小程序 `openid`，作为这个用户在这个小程序的唯一标识





## 二、流程

微信小程序登陆具体实现的逻辑如下图所示：

 ![](https://static.vue-js.com/b60638c0-3428-11ec-a752-75723a64e8f5.png)

- 通过  wx.login()  获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据
- 由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息
- 通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret  和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到
- 微信服务器返回了 openid 及本次登录的会话密钥 session_key
- 后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走
- session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输
- 然后生成 session并返回给小程序
- 小程序把 session 存到  storage 里面
- 下次请求时，先从 storage 里面读取，然后带给服务端
- 服务端对比 session 对应的记录，然后校验有效期

更加详细的功能图如下所示：

 ![](https://static.vue-js.com/c3cfbb70-3428-11ec-8e64-91fdec0f05a1.png)





## 三、扩展

实际业务中，我们还需要登录态是否过期，通常的做法是在登录态（临时令牌）中保存有效期数据，该有效期数据应该在服务端校验登录态时和约定的时间（如服务端本地的系统时间或时间服务器上的标准时间）做对比

这种方法需要将本地存储的登录态发送到小程序的服务端，服务端判断为无效登录态时再返回需重新执行登录过程的消息给小程

另一种方式可以通过调用`wx.checkSession`检查微信登陆态是否过期：

- 如果过期，则发起完整的登录流程
- 如果不过期，则继续使用本地保存的自定义登录态

这种方式的好处是不需要小程序服务端来参与校验，而是在小程序端调用AP，流程如下所示：

 ![](https://static.vue-js.com/8b446d30-349d-11ec-a752-75723a64e8f5.png)



## 参考文献

- https://segmentfault.com/a/1190000016750340
- https://juejin.cn/post/6955754095860776973
- https://www.cnblogs.com/zwh0910/p/13977278.html

# QUESTION：说说微信小程序的发布流程？

 ![](https://static.vue-js.com/d5cccdf0-3652-11ec-8e64-91fdec0f05a1.png)

## 一、背景

在中大型的公司里，人员的分工非常仔细，一般会有不同岗位角色的员工同时参与同一个小程序项目。为此，小程序平台设计了不同的权限管理使得项目管理者可以更加高效管理整个团队的协同工作

 ![](https://static.vue-js.com/e76aff50-3652-11ec-8e64-91fdec0f05a1.png)

以往我们在开发完网页之后，需要把网页的代码和资源放在服务器上，让用户通过互联网来访问

在小程序的平台里，开发者完成开发之后，需要在开发者工具提交小程序的代码包，然后在小程序后台发布小程序

 ![](https://static.vue-js.com/fe5da190-3652-11ec-8e64-91fdec0f05a1.png)





## 二、流程

关于发布的流程，主要分成了三个部分：

- 上传代码
- 提交审核
- 发布版本



### 上传代码

在开发者工具中，可以点击代码上传功能：

 ![](https://static.vue-js.com/08f19bc0-3653-11ec-a752-75723a64e8f5.png)

然后就可以填写版本信息：

 ![](https://static.vue-js.com/1d02c8f0-3653-11ec-a752-75723a64e8f5.png)

然后点击上传，编译器则会提示上传代码成功



### 提交审核

代码上传完毕，就可以登陆微信公众号的官网首页，点击【开发管理】，查看应用详情：

 ![](https://static.vue-js.com/281038e0-3653-11ec-8e64-91fdec0f05a1.png)

提交审核过程需要填写审核信息，如下图：

 ![](https://static.vue-js.com/33d97ec0-3653-11ec-a752-75723a64e8f5.png)

提交审核成功之后如下图：

 ![](https://static.vue-js.com/3e4c3550-3653-11ec-a752-75723a64e8f5.png)

### 发布版本

当审核通过之后，即可提交发布

 ![](https://static.vue-js.com/495140d0-3653-11ec-8e64-91fdec0f05a1.png)

发布成功之后则如下：

 ![](https://static.vue-js.com/5293b4c0-3653-11ec-8e64-91fdec0f05a1.png)



## 三、扩展

上述是最简单的小程序代码发布的流程，通常的流程如下：

- 代码管理服务器上新建分支
- 开发测试新需求
- 测试完成后，将本地分支合并到 master 分支
- 拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件
- 开发者工具点击“上传”
- 提审
- 发布

但是面对多人协调开发的时候，有可能出现已经上线的代码还没合并到`master`的情况

因此可以考虑自动化构建部署，就是将从开发到部署的一系列流程变成自动化，衔接连贯，在构建失败时能够告知开发者，构建成功后能够告知测试和实施人员，可参考如下流程图：

 ![](https://static.vue-js.com/602d9bf0-3653-11ec-a752-75723a64e8f5.png)


## 参考文献

- https://juejin.cn/post/6994414162700927012
- https://www.leapcloud.cn/website/docs/doc_config/xiaochengxu/xiaochengxu.html

# QUESTION：说说微信小程序的支付流程？

 ![](https://static.vue-js.com/2266fff0-34a0-11ec-8e64-91fdec0f05a1.png)



## 一、前言

微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能

在小程序内可调用微信的`API`完成支付功能，方便、快捷

场景如下图所示：

 ![](https://static.vue-js.com/6e0cff40-34a0-11ec-a752-75723a64e8f5.png)

 ![](https://static.vue-js.com/34864830-34a0-11ec-8e64-91fdec0f05a1.png)

- 用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程
- 调起微信支付控件，用户开始输入支付密码
- 密码验证通过，支付成功。商户后台得到支付成功的通知
- 返回商户小程序，显示购买成功
- 微信支付公众号下发支付凭证



## 二、流程

以电商小程序为例

支付流程图如下所示：

 ![](https://static.vue-js.com/76b66780-34a0-11ec-8e64-91fdec0f05a1.png)

具体的做法：

- 打开某小程序，点击直接下单
- wx.login获取用户临时登录凭证code，发送到后端服务器换取openId
- 在下单时，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器
- 服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息
- 小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付
- 接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付
- 鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示
- 推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态

其中后端响应数据必要的信息则是`wx.requestPayment`方法所需要的参数，大致如下：

```JS
wx.requestPayment({
  // 时间戳
  timeStamp: '',
  // 随机字符串
  nonceStr: '',
  // 统一下单接口返回的 prepay_id 参数值
  package: '',
  // 签名类型
  signType: '',
  // 签名
  paySign: '',
  // 调用成功回调
  success () {},
  // 失败回调
  fail () {},
  // 接口调用结束回调
  complete () {}
})
```

参数表如下所示：


![](https://files.mdnice.com/user/155/48efed1f-d67f-45a7-ab2c-89a6424fafa0.png)



## 三、结束

小程序支付和以往的网页、APP微信支付大同小异，可以说小程序的支付变得更加简洁，不需要设置支付目录、域名授权等操作


## 参考文献

- https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_0.shtml
- https://juejin.cn/post/6844903895970349064

-  # QUESTION：说说微信小程序的实现原理？



   ![](https://static.vue-js.com/4407cb60-3722-11ec-a752-75723a64e8f5.png)

  ## 一、背景

  网页开发，渲染线程和脚本是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应的原因，本质就是我们常说的 `JS` 是单线程的

  而在小程序中，选择了 `Hybrid` 的渲染方式，将视图层和逻辑层是分开的，双线程同时运行，视图层的界面使用 `WebView` 进行渲染，逻辑层运行在 `JSCore` 中

   ![](https://static.vue-js.com/4e322e50-3722-11ec-8e64-91fdec0f05a1.png)

  - 渲染层：界面渲染相关的任务全都在 WebView 线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程
  - 逻辑层：采用 JsCore 线程运行 JS 脚本，在这个环境下执行的都是有关小程序业务逻辑的代码



  ## 二、通信

  小程序在渲染层，宿主环境会把`wxml`转化成对应的`JS`对象

  在逻辑层发生数据变更的时候，通过宿主环境提供的`setData`方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的`Dom`树上，渲染出正确的视图

   ![](https://static.vue-js.com/5948ed10-3722-11ec-a752-75723a64e8f5.png)

  当视图存在交互的时候，例如用户点击你界面上某个按钮，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户

  对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给`JavaScript`进行处理

   ![](https://static.vue-js.com/61f9f670-3722-11ec-a752-75723a64e8f5.png)

  由于小程序是基于双线程的，也就是任何在视图层和逻辑层之间的数据传递都是线程间的通信，会有一定的延时，因此在小程序中，页面更新成了异步操作

  异步会使得各部分的运行时序变得复杂一些，比如在渲染首屏的时候，逻辑层与渲染层会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来

  如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作

  因此逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信

   ![](https://static.vue-js.com/6cb798b0-3722-11ec-a752-75723a64e8f5.png)

  ## 三、运行机制

  小程序启动运行两种情况：

  - 冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动
  - 热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动

  #### 需要注意：
  >  1.小程序没有重启的概念
  >  2.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁
  >  3.短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了

   ![](https://static.vue-js.com/968c8510-3722-11ec-a752-75723a64e8f5.png)



  开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户

  每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上



  ## 参考文献

  - https://developers.weixin.qq.com/community/develop/article/doc/0008a4c4f28f30fe3eb863b2750813
  - https://juejin.cn/post/6976805521407868958#heading-5
  - https://juejin.cn/post/6844903805675388942
  - https://juejin.cn/post/6844903999863259144#heading-1


# suanfa
# QUESTION：说说你对算法的理解？应用场景？


 ![](https://static.vue-js.com/eca03690-1620-11ec-8e64-91fdec0f05a1.png)

## 一、是什么

算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制

也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出

如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题

一个程序=算法+数据结构，数据结构是算法实现的基础，算法总是要依赖于某种数据结构来实现的，两者不可分割

因此，算法的设计和选择要同时结合数据结构，简单地说数据结构的设计就是选择存储方式，如确定问题中的信息是用数组存储还是用普通的变量存储或其他更加复杂的数据结构

针对上述，可以得出一个总结：不同的算法可能用不同的时间、空间或效率来完成同样的任务

## 二、特性

关于算法的五大特性，有如下：

- 有限性（Finiteness）：一个算法必须保证执行有限步之后结束
- 确切性（Definiteness）： 一个算法的每一步骤必须有确切的定义
- 输入（Input）：一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件
- 输出（Output）：一个算法有一个或多个输出。没有输出的算法毫无意义
- 可行性（Effectiveness）：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）


## 三、应用场景

在前端领域中，数据结构与算法无法不在，例如现在的`vue`或者`react`项目，实现虚拟`DOM`或者`Fiber`结构，本质就是一种数据结构，如下一个简单的虚拟`DOM`：

```js
{
  type: 'div',
    props: {
      name: 'lucifer'
    },
      children: [{
        type: 'span',
        props: {},
        children: []
      }]
}
```

`vue`与`react`都能基于基于对应的数据结构实现`diff`算法，提高了整个框架的性能以及拓展性

包括在前端`javascript`编译的时候，都会生成对应的抽象语法树`AST`，其本身不涉及到任何语法，因此你只要编写相应的转义规则，就可以将任何语法转义到任何语法，也是`babel`， `PostCSS`, `prettier`， `typescript`

除了这些框架或者工具底层用到算法与数据结构之外，日常业务也无处不在，例如实现一个输入框携带联想功能，如下：

 ![](https://static.vue-js.com/682d16c0-1621-11ec-8e64-91fdec0f05a1.png)

如果我们要实现这个功能， 则可以使用前缀树，如下：

 ![](https://static.vue-js.com/55a1ed50-1621-11ec-8e64-91fdec0f05a1.png)

包括前端可能会做一些对字符串进行相似度检测，例如"每日一题"和"js每日一题"两个字符串进行相似度对比，这种情况可以通过“最小编辑距离”算法，如果`a`和`b`的编辑距离越小，我们认为越相似

日常在编写任何代码的都需要一个良好的算法思维，选择好的算法或者数据结构，能让整个程序效率更高


## 参考文献

- https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025
- https://lucifer.ren/blog/2019/09/18/algorthimn-fe-1/

# QUESTION：说说你对算法中时间复杂度，空间复杂度的理解？如何计算？



 ![](https://static.vue-js.com/07fd4050-16fc-11ec-a752-75723a64e8f5.png)

## 一、前言

算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别

衡量不同算法之间的优劣主要是通过**时间**和**空间**两个维度去考量：

- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述

通常会遇到一种情况，时间和空间维度不能够兼顾，需要在两者之间取得一个平衡点是我们需要考虑的

一个算法通常存在最好、平均、最坏三种情况，我们一般关注的是最坏情况

最坏情况是算法运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，也意味着平均情况和最坏情况一样差



## 二、时间复杂度

时间复杂度是指执行这个算法所需要的计算工作量，其复杂度反映了程序执行时间「随输入规模增长而增长的量级」，在很大程度上能很好地反映出算法的优劣与否

一个算法花费的时间与算法中语句的「执行次数成正比」，执行次数越多，花费的时间就越多

算法的复杂度通常用大O符号表述，定义为`T(n) = O(f(n))`，常见的时间复杂度有：O(1)常数型、O(log n)对数型、O(n)线性型、O(nlogn)线性对数型、O(n^2)平方型、O(n^3)立方型、O(n^k)k次方型、O(2^n)指数型，如下图所示：

 ![](https://static.vue-js.com/33d5ebf0-16fc-11ec-8e64-91fdec0f05a1.png)

从上述可以看到，随着问题规模`n`的不断增大，上述时间复杂度不断增大，算法的执行效率越低，由小到大排序如下：

```js
Ο(1)＜Ο(log n)＜Ο(n)＜Ο(nlog n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n)＜Ο(n!)
```

注意的是，算法复杂度只是描述算法的增长趋势，并不能说一个算法一定比另外一个算法高效，如果常数项过大的时候也会导致算法的执行时间变长

关于如何计算时间复杂度，可以看看如下简单例子：

```js
function process(n) {
  let a = 1
  let b = 2
  let sum = a + b
  for(let i = 0; i < n; i++) {
    sum += i
  }
  return sum
}
```

该函数算法需要执行的运算次数用输入大小`n`的函数表示，即 `T(n) = 2 + n  + 1`，那么时间复杂度为`O(n + 3)`，又因为时间复杂度只关注最高数量级，且与之系数也没有关系，因此上述的时间复杂度为`O(n)`

又比如下面的例子：

```js
function process(n) {
 let count = 0
  for(let i = 0; i < n; i++){
    for(let i = 0; i < n; i++){
      count += 1
    }
  }
}
```

循环里面嵌套循环，外面的循环执行一次，里面的循环执行`n`次，因此时间复杂度为 `O(n*n*1 + 2) = O(n^2)`

对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，如下：

```js
function process(n) {
  let sum = 0
  for(let i = 0; i < n; i++) {
    sum += i
  }
  for(let i = 0; i < n; i++){
    for(let i = 0; i < n; i++){
      sum += 1
    }
  }
  return sum
}
```

上述第一部分复杂度为`O(n)`，第二部分复杂度为`O(n^2)`，总复杂度为`max(O(n^2), O(n)) = O(n^2)`

又如下一个例子：

```js
function process(n) {
  let i = 1; // ①
  while (i <= n) {
     i = i * 2; // ②
  }
}
```

循环语句中以2的倍数来逼近`n`，每次都乘以2。如果用公式表示就是1 *  2 * 2 * 2 … * 2 <=n，也就是说2的`x`次方小于等于`n`时会执行循环体，记作`2^x <= n`，于是得出`x<=logn`

因此循环在执行`logn`次之后，便结束，因此时间复杂度为`O(logn)`

同理，如果一个`O(n)`循环里面嵌套`O(logn)`的循环，则时间复杂度为`O(nlogn)`，像`O(n^3)`无非也就是嵌套了三层`O(n)`循环



## 三、空间复杂度

空间复杂度主要指执行算法所需内存的大小，用于对程序运行过程中所需要的临时存储空间的度量

除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间

下面给出空间复杂度为`O(1)`的示例，如下

```js
let a = 1
let b = 2
let c = 3
```

上述代码的临时空间不会随着`n`的变化而变化，因此空间复杂度为`O(1)`

```js
let arr []
for(i=1; i<=n; ++i){
  arr.push(i)
}
```

上述可以看到，随着`n`的增加，数组的占用的内存空间越大

通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为`O(1)`，一个一维数组`a[n]`，空间复杂度`O(n)`，二维数组为`O(n^2)`





## 参考文献

- https://juejin.cn/post/6844904167824162823#heading-7

- https://zhuanlan.zhihu.com/p/50479555

- https://cloud.tencent.com/developer/article/1769988


# QUESTION：说说你对数据结构的理解？有哪些？区别？

 ![](https://static.vue-js.com/3d87b540-1aa6-11ec-a752-75723a64e8f5.png)



## 一、是什么

数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合

前面讲到，一个程序 = 算法 + 数据结构，数据结构是实现算法的基础，选择合适的数据结构可以带来更高的运行或者存储效率

数据元素相互之间的关系称为结构，根据数据元素之间关系的不同特性，通常有如下四类基本的结构：

- 集合结构：该结构的数据元素间的关系是“属于同一个集合”
- 线性结构：该结构的数据元素之间存在着一对一的关系
- 树型结构：该结构的数据元素之间存在着一对多的关系
- 图形结构：该结构的数据元素之间存在着多对多的关系，也称网状结构

由于数据结构种类太多，逻辑结构可以再分成为：

- 线性结构：有序数据元素的集合，其中数据元素之间的关系是一对一的关系，除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的
- 非线性结构：各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生关联

![](https://static.vue-js.com/9aedc5d0-1aa6-11ec-8e64-91fdec0f05a1.png)

## 二、有哪些

常见的数据结构有如下：

- 数组
- 栈
- 队列
- 链表
- 树
- 图
- 堆
- 散列表


### 数组

在程序设计中，为了处理方便， 一般情况把具有相同类型的若干变量按有序的形式组织起来，这些按序排列的同类数据元素的集合称为数组


### 栈

一种特殊的线性表，只能在某一端插入和删除的特殊线性表，按照先进后出的特性存储数据

先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据



### 队列

跟栈基本一致，也是一种特殊的线性表，其特性是先进先出，只允许在表的前端进行删除操作，而在表的后端进行插入操作



### 链表

是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的

链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成

一般情况，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域



### 树

树是典型的非线性结构，在树的结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个以上的后继结点



### 图

一种非线性结构。在图结结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系



### 堆

堆是一种特殊的树形数据结构，每个结点都有一个值，特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆



### 散列表

若结构中存在关键字和`K`相等的记录，则必定在`f(K)`的存储位置上，不需比较便可直接取得所查记录



## 三、区别

上述的数据结构，之前的区别可以分成线性结构和非线性结构：

- 线性结构有：数组、栈、队列、链表等
- 非线性结构有：树、图、堆等


## 参考文献

- https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84
- https://baike.baidu.com/item/数据结构/1450


# QUESTION：说说你对栈、队列的理解？应用场景？

 ![](https://static.vue-js.com/bc57f530-1b99-11ec-a752-75723a64e8f5.png)

## 一、栈

栈（stack）又名堆栈，它是一种运算受限的线性表，限定仅在表尾进行插入和删除操作的线性表

表尾这一端被称为栈顶，相反地另一端被称为栈底，向栈顶插入元素被称为进栈、入栈、压栈，从栈顶删除元素又称作出栈

所以其按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据，具有记忆作用

关于栈的简单实现，如下：

```js
class Stack {
  constructor() {
    this.items = [];
  }

  /**
   * 添加一个（或几个）新元素到栈顶
   * @param {*} element 新元素
   */
  push(element) {
    this.items.push(element)
  }

  /**
   * 移除栈顶的元素，同时返回被移除的元素
   */
  pop() {
    return this.items.pop()
  }

  /**
   * 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）
   */
  peek() {
    return this.items[this.items.length - 1]
  }

  /**
   * 如果栈里没有任何元素就返回true,否则返回false
   */
  isEmpty() {
    return this.items.length === 0
  }

  /**
   * 移除栈里的所有元素
   */
  clear() {
    this.items = []
  }

  /**
   * 返回栈里的元素个数。这个方法和数组的length属性很类似
   */
  size() {
    return this.items.length
  }
}
```

关于栈的操作主要的方法如下：

- push：入栈操作
- pop：出栈操作





## 二、队列

跟栈十分相似，队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作

进行插入操作的端称为队尾，进行删除操作的端称为队头，当队列中没有元素时，称为空队列

在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出

简单实现一个队列的方式，如下：

```js
class Queue {
    constructor() {
        this.list = []
        this.frontIndex = 0
        this.tailIndex = 0
    }
    enqueue(item) {
        this.list[this.tailIndex++] = item
    }
    unqueue() {
        const item  = this.list[this.frontIndex]
        this.frontIndex++
        return item
    }
}
```

上述这种入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用

当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作，出该现象称为"假溢"

在实际使用队列时，为了使队列空间能重复使用，往往对队列的使用方法稍加改进：

无论插入或删除，一旦`rear`指针增1或`front`指针增1 时超出了所分配的队列空间，就让它指向这片连续空间的起始位置，这种队列也就是循环队列

下面实现一个循环队列，如下：

```js
class Queue {
    constructor(size) {
        this.size = size; // 长度需要限制, 来达到空间的利用, 代表空间的长度
        this.list = [];
        this.font = 0; // 指向首元素
        this.rear = 0;  // 指向准备插入元素的位置
    }
    enQueue() {
        if (this.isFull() == true) {
            return false
        }
        this.rear = this.rear % this.k;
        this._data[this.rear++] = value;
        return true
    }
    deQueue() {
        if(this.isEmpty()){
            return false;
        }
        this.font++;
        this.font = this.font % this.k;
        return true;
    }
    isEmpty() {
        return this.font == this.rear - 1;
    }
    isFull() {
        return this.rear % this.k == this.font;
    }
}
```

上述通过求余的形式代表首尾指针增1 时超出了所分配的队列空间



## 三、应用场景

### 栈

借助栈的先进后出的特性，可以简单实现一个逆序数处的功能，首先把所有元素依次入栈，然后把所有元素出栈并输出

包括编译器的在对输入的语法进行分析的时候，例如`"()"`、`"{}"`、`"[]"`这些成对出现的符号，借助栈的特性，凡是遇到括号的前半部分，即把这个元素入栈，凡是遇到括号的后半部分就比对栈顶元素是否该元素相匹配，如果匹配，则前半部分出栈，否则就是匹配出错

包括函数调用和递归的时候，每调用一个函数，底层都会进行入栈操作，出栈则返回函数的返回值

生活中的例子，可以把乒乓球盒比喻成一个堆栈，球一个一个放进去（入栈），最先放进去的要等其后面的全部拿出来后才能出来（出栈），这种就是典型的先进后出模型

### 队列

当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题

队列的使用广泛应用在广度优先搜索种，例如层次遍历一个二叉树的节点值（后续将到）

生活中的例子，排队买票，排在队头的永远先处理，后面的必须等到前面的全部处理完毕再进行处理，这也是典型的先进先出模型

## 参考文献

- https://baike.baidu.com/item/%E6%A0%88/12808149
- https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481


# QUESTION：说说你对链表的理解？常见的操作有哪些？

 ![](https://static.vue-js.com/d6638dd0-1c76-11ec-8e64-91fdec0f05a1.png)

## 一、是什么

链表（Linked List）是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，由一系列结点（链表中每一个元素称为结点）组成

每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域

 ![](https://static.vue-js.com/e4e93490-1c76-11ec-8e64-91fdec0f05a1.png)

节点用代码表示，则如下：

```js
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}
```

- data 表示节点存放的数据
- next 表示下一个节点指向的内存空间

相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到`O(1)`的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是`O(logn)`和`O(1)`

链表的结构也十分多，常见的有四种形式：

- 单链表：除了头节点和尾节点，其他节点只包含一个后继指针
- 循环链表：跟单链表唯一的区别就在于它的尾结点又指回了链表的头结点，首尾相连，形成了一个环
- 双向链表：每个结点具有两个方向指针，后继指针(next)指向后面的结点，前驱指针(prev)指向前面的结点，其中节点的前驱指针和尾结点的后继指针均指向空地址NULL
- 双向循环链表：跟双向链表基本一致，不过头节点前驱指针指向尾迹诶单和尾节点的后继指针指向头节点



## 二、操作

关于链表的操作可以主要分成如下：

- 遍历
- 插入
- 删除

### 遍历

遍历很好理解，就是根据`next`指针遍历下去，直到为`null`，如下：

```js
let current = head
while(current){
 console.log(current.val)
  current = current.next
}
```

### 插入

向链表中间插入一个元素，可以如下图所示：

 ![](https://static.vue-js.com/f5fe5fd0-1c76-11ec-8e64-91fdec0f05a1.png)

可以看到，插入节点可以分成如下步骤：

- 存储插入位置的前一个节点
- 存储插入位置的后一个节点

- 将插入位置的前一个节点的 next 指向插入节点
- 将插入节点的 next 指向前面存储的 next 节点

相关代码如下所示：

```js
let current = head
while (current < position){
  pervious = current;
  current = current.next;
}
pervious.next = node;
node.next = current;

```

如果在头节点进行插入操作的时候，会实现`previousNode`节点为`undefined`，不适合上述方式

解放方式可以是在头节点前面添加一个虚拟头节点，保证插入行为一致



### 删除

向链表任意位置删除节点，如下图操作：

 ![](https://static.vue-js.com/0160cd90-1c77-11ec-a752-75723a64e8f5.png)

从上图可以看到删除节点的步骤为如下：

- 获取删除节点的前一个节点
- 获取删除节点的后一个节点
- 将前一个节点的 next 指向后一个节点
- 向删除节点的 next 指向为null

如果想要删除制定的节点，示意代码如下：

```js
while (current != node){
  pervious = current;
  current = current.next;
  nextNode = current.next;
}
pervious.next = nextNode
```

同样如何希望删除节点处理行为一致，可以在头节点前面添加一个虚拟头节点



## 三、应用场景

缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的`CPU`缓存、数据库缓存、浏览器缓存等等

当缓存空间被用满时，我们可能会使用`LRU`最近最好使用策略去清楚，而实现`LRU`算法的数据结构是链表，思路如下：

维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表

- 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据的对应结点，并将其从原来的位置删除，并插入到链表头部
- 如果此数据没在缓存链表中
  - 如果此时缓存未满，可直接在链表头部插入新节点存储此数据
  - 如果此时缓存已满，则删除链表尾部节点，再在链表头部插入新节点

由于链表插入删除效率极高，达到O(1)。对于不需要搜索但变动频繁且无法预知数量上限的数据的情况的时候，都可以使用链表


## 参考文献
- https://zh.wikipedia.org/zh-hans/%E9%93%BE%E8%A1%A8
- https://mah93.github.io/2019/07/19/js-linked/


# QUESTION：说说你对集合的理解？常见的操作有哪些？



 ![](https://static.vue-js.com/e3de7810-1d36-11ec-8e64-91fdec0f05a1.png)



## 一、是什么

集合（Set），指具有某种特定性质的事物的总体，里面的每一项内容称作元素

在数学中，我们经常会遇到集合的概念：

- 有限集合：例如一个班集所有的同学构成的集合
- 无限集合：例如全体自然数集合

在计算机中集合道理也基本一致，具有三大特性：

- 确定性：于一个给定的集合，集合中的元素是确定的。即一个元素，或者属于该集合，或者不属于该集合，两者必居其一
- 无序性：在一个集合中，不考虑元素之间的顺序，只要元素完全相同，就认为是同一个集合
- 互异性：集合中任意两个元素都是不同的


## 二、操作

在`ES6`中，集合本身是一个构建函数`Set`，用来生成 `Set` 数据结构，如下：

```js
const s = new Set();
```

关于集合常见的方法有：

- add()：增
- delete()：删
- has()：改
- clear()：查



### add()

添加某个值，返回 `Set` 结构本身

当添加实例中已经存在的元素，`set`不会进行处理添加

```js
s.add(1).add(2).add(2); // 2只被添加了一次
```

体现了集合的互异性特性

### delete()

删除某个值，返回一个布尔值，表示删除是否成功

```js
s.delete(1)
```

### has()

返回一个布尔值，判断该值是否为`Set`的成员

```js
s.has(2)
```

### clear()

清除所有成员，没有返回值

```js
s.clear()
```



关于多个集合常见的操作有：

- 并集
- 交集
- 差集



### 并集

两个集合的共同元素，如下图所示：

 ![](https://static.vue-js.com/ed96df50-1d36-11ec-a752-75723a64e8f5.png)

代码实现方式如下：

```js
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}
```





### 交集

两个集合`A` 和 `B`，即属于`A`又属于`B`的元素，如下图所示：

 ![](https://static.vue-js.com/f8a9cd80-1d36-11ec-a752-75723a64e8f5.png)

用代码标识则如下：

```js
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}
```



### 差集

两个集合`A` 和 `B`，属于`A`的元素但不属于`B`的元素称为`A`相对于`B`的差集，如下图所示：

 ![](https://static.vue-js.com/0191c560-1d37-11ec-8e64-91fdec0f05a1.png)

代码标识则如下：

```js
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}
```





## 三、应用场景

一般情况下，使用数组的概率会比集合概率高很多

使用`set`集合的场景一般是借助其确定性，其本身只包含不同的元素

所以，可以利用`Set`的一些原生方法轻松的完成数组去重，查找数组公共元素及不同元素等操作





## 参考文献

- https://zh.wikipedia.org/wiki/%E5%B9%B6%E9%9B%86
- https://zh.wikipedia.org/wiki/%E8%A1%A5%E9%9B%86


# QUESTION：说说你对树的理解？相关的操作有哪些？



 ![](https://static.vue-js.com/5a7616f0-1dfe-11ec-8e64-91fdec0f05a1.png)



## 一、是什么

在计算机领域，树形数据结构是一类重要的非线性数据结构，可以表示数据之间一对多的关系。以树与二叉树最为常用，直观看来，树是以分支关系定义的层次结构

二叉树满足以下两个条件：

- 本身是有序树
- 树中包含的各个结点的不能超过 2，即只能是 0、1 或者 2

如下图，左侧的为二叉树，而右侧的因为头结点的子结点超过2，因此不属于二叉树：

 ![](https://static.vue-js.com/66758800-1dfe-11ec-a752-75723a64e8f5.png)

同时，二叉树可以继续进行分类，分成了满二叉树和完成二叉树：

- 满二叉树：如果二叉树中除了叶子结点，每个结点的度都为 2

 ![](https://static.vue-js.com/759db050-1dfe-11ec-a752-75723a64e8f5.png)

- 完成二叉树：如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布

 ![](https://static.vue-js.com/84ae31f0-1dfe-11ec-8e64-91fdec0f05a1.png)

## 二、操作

关于二叉树的遍历，常见的有：

- 前序遍历
- 中序遍历
- 后序遍历

- 层序遍历





### 前序遍历

前序遍历的实现思想是：

- 访问根节点
- 访问当前节点的左子树
- 若当前节点无左子树，则访问当前节点的右子

根据遍历特性，递归版本用代码表示则如下：

```js
const preOrder = (root) => {
  if(!root){ return }
  console.log(root)
  preOrder(root.left)
  preOrder(root.right)
}
```

如果不使用递归版本，可以借助栈先进后出的特性实现，先将根节点压入栈，再分别压入右节点和左节点，直到栈中没有元素，如下：

```js
const preOrder = (root) => {
  if(!root){ return }
  const stack = [root]
  while (stack.length) {
    const n = stack.pop()
    console.log(n.val)
    if (n.right) {
      stack.push(n.right)
    }
    if (n.left) {
      stack.push(n.left)
    }
  }
}
```





### 中序遍历

前序遍历的实现思想是：

- 访问当前节点的左子树
- 访问根节点
- 访问当前节点的右子

递归版本很好理解，用代码表示则如下：

```js
const inOrder = (root) => {
  if (!root) { return }
  inOrder(root.left)
  console.log(root.val)
  inOrder(root.right)
}
```

非递归版本也是借助栈先进后出的特性，可以一直首先一直压入节点的左元素，当左节点没有后，才开始进行出栈操作，压入右节点，然后有依次压入左节点，如下：

```js
const inOrder = (root) => {
  if (!root) { return }
  const stack = [root]
  let p = root
  while(stack.length || p){
    while (p) {
      stack.push(p)
      p = p.left
    }
    const n = stack.pop()
    console.log(n.val)
    p = n.right
  }
}
```





### 后序遍历

前序遍历的实现思想是：

- 访问当前节点的左子树
- 访问当前节点的右子
- 访问根节点

递归版本，用代码表示则如下：

```js
const postOrder = (root) => {
  if (!root) { return }
  postOrder(root.left)
  postOrder(root.right)
  console.log(n.val)
 }
```

后序遍历非递归版本实际根全序遍历是逆序关系，可以再多创建一个栈用来进行输出，如下：

```js
const preOrder = (root) => {
  if(!root){ return }
  const stack = [root]
  const outPut = []
  while (stack.length) {
    const n = stack.pop()
    outPut.push(n.val)
    if (n.right) {
      stack.push(n.right)
    }
    if (n.left) {
      stack.push(n.left)
    }
  }
  while (outPut.length) {
    const n = outPut.pop()
    console.log(n.val)
  }
}
```





### 层序遍历

按照二叉树中的层次从左到右依次遍历每层中的结点

借助队列先进先出的特性，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果

用代码表示则如下：

```js
const levelOrder = (root) => {
    if (!root) { return [] }
    const queue = [[root, 0]]
    const res = []
    while (queue.length) {
        const n = queue.shift()
        const [node, leval] = n
        if (!res[leval]) {
            res[leval] = [node.val]
        } else {
            res[leval].push(node.val)
        }
        if (node.left) { queue.push([node.left, leval + 1]) }
        if (node.right) { queue.push([node.right, leval + 1]) }
    }
    return res
};
```





## 三、总结

树是一个非常重要的非线性结构，其中二叉树以二叉树最常见，二叉树的遍历方式可以分成前序遍历、中序遍历、后序遍历

同时，二叉树又分成了完成二叉树和满二叉树


## 参考文献

- https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91
- http://data.biancheng.net/view/27.html


# QUESTION：说说你对堆的理解？如何实现？应用场景？


 ![](https://static.vue-js.com/dd12c700-1ed7-11ec-8e64-91fdec0f05a1.png)


## 一、是什么

堆(Heap)是计算机科学中一类特殊的数据结构的统称

堆通常是一个可以被看做一棵完全二叉树的数组对象，如下图：

 ![](https://static.vue-js.com/ea0fd1f0-1ed7-11ec-8e64-91fdec0f05a1.png)

总是满足下列性质：

- 堆中某个结点的值总是不大于或不小于其父结点的值
- 堆总是一棵完全二叉树

堆又可以分成最大堆和最小堆：

- 最大堆：每个根结点，都有根结点的值大于两个孩子结点的值
- 最小堆：每个根结点，都有根结点的值小于孩子结点的值



## 二、操作

堆的元素存储方式，按照完全二叉树的顺序存储方式存储在一个一维数组中，如下图：

![](https://static.vue-js.com/ea0fd1f0-1ed7-11ec-8e64-91fdec0f05a1.png)

用一维数组存储则如下：

```js
[0, 1, 2, 3, 4, 5, 6, 7, 8]
```

根据完全二叉树的特性，可以得到如下特性：

- 数组零坐标代码的是堆顶元素
- 一个节点的父亲节点的坐标等于其坐标除以2整数部分
- 一个节点的左节点等于其本身节点坐标 * 2 + 1
- 一个节点的右节点等于其本身节点坐标 * 2 + 2



根据上述堆的特性，下面构建最小堆的构造函数和对应的属性方法：

```js
class MinHeap {
  constructor() {
    // 存储堆元素
    this.heap = []
  }
  // 获取父元素坐标
  getParentIndex(i) {
    return (i - 1) >> 1
  }

  // 获取左节点元素坐标
  getLeftIndex(i) {
    return i * 2 + 1
  }

 // 获取右节点元素坐标
  getRightIndex(i) {
    return i * 2 + 2
  }

  // 交换元素
  swap(i1, i2) {
    const temp = this.heap[i1]
    this.heap[i1] = this.heap[i2]
    this.heap[i2] = temp
  }

  // 查看堆顶元素
  peek() {
    return this.heap[0]
  }

  // 获取堆元素的大小
  size() {
    return this.heap.length
  }
}
```





涉及到堆的操作有：

- 插入
- 删除



### 插入

将值插入堆的底部，即数组的尾部，当插入一个新的元素之后，堆的结构就会被破坏，因此需要堆中一个元素做上移操作

将这个值和它父节点进行交换，直到父节点小于等于这个插入的值，大小为`k`的堆中插入元素的时间复杂度为`O(logk)`

如下图所示，22节点是新插入的元素，然后进行上移操作：

 ![](https://static.vue-js.com/06893fb0-1ed8-11ec-8e64-91fdec0f05a1.png)

相关代码如下：

```js
// 插入元素
insert(value) {
  this.heap.push(value)
  this.shifUp(this.heap.length - 1)
}

// 上移操作
shiftUp(index) {
  if (index === 0) { return }
  const parentIndex = this.getParentIndex(index)
  if(this.heap[parentIndex] > this.heap[index]){
    this.swap(parentIndex, index)
    this.shiftUp(parentIndex)
  }
}
```


### 删除

常见操作是用数组尾部元素替换堆顶，这里不直接删除堆顶，因为所有的元素会向前移动一位，会破坏了堆的结构

然后进行下移操作，将新的堆顶和它的子节点进行交换，直到子节点大于等于这个新的堆顶，删除堆顶的时间复杂度为`O(logk)`

整体如下图操作：

 ![](https://static.vue-js.com/12a2a160-1ed8-11ec-a752-75723a64e8f5.png)

相关代码如下：

```js
// 删除元素
pop() {
  this.heap[0] = this.heap.pop()
  this.shiftDown(0)
}

// 下移操作
shiftDown(index) {
  const leftIndex = this.getLeftIndex(index)
  const rightIndex = this.getRightIndex(index)
  if (this.heap[leftIndex] < this.heap[index]){
    this.swap(leftIndex, index)
    this.shiftDown(leftIndex)
  }
  if (this.heap[rightIndex] < this.heap[index]){
    this.swap(rightIndex, index)
    this.shiftDown(rightIndex)
  }
}
```



### 时间复杂度

关于堆的插入和删除时间复杂度都是`Olog(n)`，原因在于包含n个节点的完全二叉树，树的高度不会超过`log2n`

堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是`Olog(n)`，插入数据和删除堆顶元素的主要逻辑就是堆化


### 三、总结

- 堆是一个完全二叉树
- 堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值
- 对于每个节点的值都大于等于子树中每个节点值的堆，叫作“大顶堆”
- 对于每个节点的值都小于等于子树中每个节点值的堆，叫作“小顶堆”
- 根据堆的特性，我们可以使用堆来进行排序操作，也可以使用其来求第几大或者第几小的值


## 参考文献

- https://baike.baidu.com/item/%E5%A0%86/20606834
- https://xlbpowder.cn/2021/02/26/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/


# QUESTION：说说你对图的理解？相关操作有哪些？


 ![](https://static.vue-js.com/7876c2f0-2059-11ec-8e64-91fdec0f05a1.png)


## 一、是什么

在计算机科学中，图是一种抽象的数据类型，在图中的数据元素通常称为结点，`V`是所有顶点的集合，`E`是所有边的集合

如果两个顶点`v`,` w`，只能由`v`向`w`，而不能由`w`向`v`，那么我们就把这种情况叫做一个从 `v` 到 `w` 的有向边。`v `也被称做初始点，`w`也被称为终点。这种图就被称做有向图

如果`v`和`w`是没有顺序的，从`v`到达`w`和从`w`到达`v`是完全相同的，这种图就被称为无向图

图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系

常见表达图的方式有如下：

- 邻接矩阵

- 邻接表

### 邻接矩阵

通过使用一个二维数组`G[N][N]`进行表示`N`个点到`N-1`编号，通过邻接矩阵可以立刻看出两顶点之间是否存在一条边，只需要检查邻接矩阵行`i`和列`j`是否是非零值，对于无向图，邻接矩阵是对称的

 ![](https://static.vue-js.com/881d4300-2059-11ec-a752-75723a64e8f5.png)



### 邻接表

存储方式如下图所示：

 ![](https://static.vue-js.com/949fedd0-2059-11ec-a752-75723a64e8f5.png)

在`javascript`中，可以使用`Object`进行表示，如下：

```js
const graph = {
  A: [2, 3, 5],
  B: [2],
  C: [0, 1, 3],
  D: [0, 2],
  E: [6],
  F: [0, 6],
  G: [4, 5]
}
```

图的数据结构还可能包含和每条边相关联的数值（edge value），例如一个标号或一个数值（即权重，weight；表示花费、容量、长度等）





## 二、操作

关于的图的操作常见的有：

- 深度优先遍历
- 广度优先遍历



首先构建一个图的邻接矩阵表示，如下面的图：

 ![](https://static.vue-js.com/a1311790-2059-11ec-8e64-91fdec0f05a1.png)

用代码表示则如下：

```js
const graph = {
  0: [1, 4],
  1: [2, 4],
  2: [2, 3],
  3: [],
  4: [3],
}
```





### 深度优先遍历

也就是尽可能的往深处的搜索图的分支

实现思路是，首先应该确定一个根节点，然后对根节点的没访问过的相邻节点进行深度优先遍历

确定以 0 为根节点，然后进行深度遍历，然后遍历1，接着遍历 2，然后3，此时完成一条分支`0 - 1- 2- 3`的遍历，换一条分支，也就是4，4后面因为3已经遍历过了，所以就不访问了

用代码表示则如下：

```js
const visited = new Set()
const dfs = (n) => {
  console.log(n)
  visited.add(n) // 访问过添加记录
  graph[n].forEach(c => {
    if(!visited.has(c)){ // 判断是否访问呢过
      dfs(c)
    }
  })
}
```



### 广度优先遍历

先访问离根节点最近的节点，然后进行入队操作，解决思路如下：

- 新建一个队列，把根节点入队
- 把队头出队并访问
- 把队头的没访问过的相邻节点入队
- 重复二、三步骤，知道队列为空

用代码标识则如下：

```js
const visited = new Set()
const dfs = (n) => {
  visited.add(n)
  const q = [n]
  while(q.length){
    const n = q.shift()
    console.log(n)
    graph[n].forEach(c => {
      if(!visited.has(c)){
        q.push(c)
        visited.add(c)
      }
    })
  }
}
```



## 三、总结

通过上面的初步了解，可以看到图就是由顶点的有穷非空集合和顶点之间的边组成的集合，分成了无向图与有向图

图的表达形式可以分成邻接矩阵和邻接表两种形式，在`javascript`中，则可以通过二维数组和对象的形式进行表达

图实际是很复杂的，后续还可以延伸出无向图和带权图，对应如下图所示：

 ![](https://static.vue-js.com/b0d88200-2059-11ec-8e64-91fdec0f05a1.png)





## 参考文献

- https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
- https://www.kancloud.cn/imnotdown1019/java_core_full/2159607


# QUESTION：说说常见的排序算法有哪些？区别？


 ![](https://static.vue-js.com/63eb7920-211c-11ec-a752-75723a64e8f5.png)

## 一、是什么

排序是程序开发中非常常见的操作，对一组任意的数据元素经过排序操作后，就可以把他们变成一组一定规则排序的有序序列

排序算法属于算法中的一种，而且是覆盖范围极小的一种，彻底掌握排序算法对程序开发是有很大的帮助的

对与排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性

时间复杂度、空间复杂度前面已经讲过，这里主要看看稳定性的定义

稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变

即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的



## 二、有哪些

常见的算法排序算法有：

- 冒泡排序
- 选择排序
- 插入排序
- 归并排序
- 快速排序

### 冒泡排序

一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来

思路如下：

- 比较相邻的元素，如果第一个比第二个大，就交换它们两个

- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数
- 针对所有的元素重复以上的步骤，除了最后一个
- 重复上述步骤，直到没有任何一堆数字需要比较

![](https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp)



### 选择排序

选择排序是一种简单直观的排序算法，它也是一种交换排序算法

无论什么数据进去都是 `O(n²) `的时间复杂度。所以用到它的时候，数据规模越小越好

唯一的好处是不占用额外的内存存储空间

思路如下：

- 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
- 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
- 重复第二步，直到所有元素均排序完毕

![](https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp)





### 插入排序

插入排序是一种简单直观的排序算法

它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

解决思路如下：

- 把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的
- 从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
- 重复上述过程直到最后一个元素被插入有序子数组中

![](https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp)



### 归并排序

归并排序是建立在归并操作上的一种有效的排序算法

该算法是采用分治法的一个非常典型的应用

将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序

解决思路如下：

- 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
- 设定两个指针，最初位置分别为两个已经排序序列的起始位置
- 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
- 重复步骤3直到某一指针到达序列尾
- 将另一序列剩下的所有元素直接复制到合并序列尾

![](https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg)



### 快速排序

快速排序是对冒泡排序算法的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小

再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列

解决思路如下：

- 从数列中挑出一个元素，称为"基准"（pivot）
- 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作
- 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序

![](https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.jpg)



## 三、区别

除了上述的排序算法之外，还存在其他的排序算法，例如希尔排序、堆排序等等......

区别如下图所示：

![](https://static.vue-js.com/5c3d7b50-2131-11ec-a752-75723a64e8f5.png)



## 参考文献

- https://www.runoob.com/w3cnote/bubble-sort.html
- http://www.x-lab.info/post/sort-algorithm/
- https://zhuanlan.zhihu.com/p/42586566

# QUESTION：说说你对冒泡排序的理解？如何实现？应用场景？

 ![](https://static.vue-js.com/6f5e0850-2652-11ec-a752-75723a64e8f5.png)


## 一、是什么

冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法

冒泡排序的思想就是在每次遍历一遍未排序的数列之后，将一个数据元素浮上去（也就是排好了一个数据）

如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”

假如我们要把 12、35、99、18、76 这 5 个数从大到小进行排序，那么数越大，越需要把它放在前面

思路如下：

- 从后开始遍历，首先比较 18 和 76，发现 76 比 18 大，就把两个数交换顺序，得到 12、35、99、76、18
- 接着比较 76 和 99，发现 76 比 99 小，所以不用交换顺序
- 接着比较 99 和 35，发现 99 比 35 大，交换顺序
- 接着比较 99 和 12，发现 99 比 12 大，交换顺序

最终第 1 趟排序的结果变成了 99、12、35、76、18，如下图所示：

 ![](https://static.vue-js.com/7a363770-2652-11ec-8e64-91fdec0f05a1.png)

上述可以看到，经过第一趟的排序，可以得到最大的元素，接下来第二趟排序则对剩下的的4个元素进行排序，如下图所示：

 ![](https://static.vue-js.com/84b9ddf0-2652-11ec-a752-75723a64e8f5.png)

经过第 2 趟排序，结果为 99、76、12、35、18

然后开始第3趟的排序，结果为99、76、35、12、18

然后第四趟排序结果为99、76、35、18、12

经过 4 趟排序之后，只剩一个 12 需要排序了，这时已经没有可比较的元素了，这时排序完成

## 二、如何实现

如果要实现一个从小到大的排序，算法原理如下：

- 首先比较相邻的元素，如果第一个元素比第二个元素大，则交换它们
- 针对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样，最后的元素回事最大的数
- 针对所有的元素重复以上的步骤，除了最后一个
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

![](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)

用代码表示则如下：

```js
function bubbleSort(arr) {
    const len = arr.length;
    for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
```

可以看到：冒泡排序在每一轮排序中都会使一个元素排到一趟， 也就是最终需要 n-1 轮这样的排序

而在每轮排序中都需要对相邻的两个元素进行比较，在最坏的情况下，每次比较之后都需要交换位置，此时时间复杂度为`O(n^2)`



### 优化

对冒泡排序常见的改进方法是加入一标志性变量`exchange`，用于标志某一趟排序过程中是否有数据交换

如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程

可以设置一标志性变量`pos`，用于记录每趟排序中最后一次进行交换的位置，由于`pos`位置之后的记录均已交换到位，故在进行下一趟排序时只要扫描到`pos`位置即可，如下：

```js
function bubbleSort1(arr){
 const i=arr.length-1;//初始时,最后位置保持不变
 while(i>0){
  let pos = 0;//每趟开始时,无记录交换
  for(let j = 0; j < i; j++){
   if(arr[j] > arr[j+1]){
        let tmp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = tmp;
    pos = j;//记录最后交换的位置
   }
  }
  i = pos;//为下一趟排序作准备
 }
 return arr;
}
```

在待排序的数列有序的情况下，只需要一轮排序并且不用交换，此时情况最好，时间复杂度为`O(n)`

并且从上述比较中看到，只有后一个元素比前面的元素大（小）时才会对它们交换位置并向上冒出，对于同样大小的元素，是不需要交换位置的，所以对于同样大小的元素来说，相对位置是不会改变的，因此， 冒泡排序是稳定的





## 三、应用场景
冒泡排的核心部分是双重嵌套循环，
时间复杂度是 O(N 2 )，相比其它排序算法，这是一个相对较高的时间复杂度，一般情况不推荐使用，由于冒泡排序的简洁性，通常被用来对于程序设计入门的学生介绍算法的概念

## 参考文献

- https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306
- https://www.runoob.com/w3cnote/bubble-sort.html
- http://data.biancheng.net/view/116.html
- https://dsb123dsb.github.io/2017/03/07/js%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/


# QUESTION：说说你对选择排序的理解？如何实现？应用场景？

 ![](https://static.vue-js.com/50a05ed0-2671-11ec-a752-75723a64e8f5.png)

## 一、是什么

选择排序（Selection sort）是一种简单直观的排序算法，无论什么数据进去都是 `O(n²) `的时间复杂度，所以用到它的时候，数据规模越小越好

其基本思想是：首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置

然后再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾

以此类推，直到所有元素均排序完毕

举个例子，一个数组为 56、12、80、91、29，其排序过程如下：

- 第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置。此时数组为 12、56、80、91、20

 ![](https://static.vue-js.com/60bd2050-2671-11ec-a752-75723a64e8f5.png)

- 第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置，此时数组为12、20、80、91、56

 ![](https://static.vue-js.com/6b04cf40-2671-11ec-8e64-91fdec0f05a1.png)

- 第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置，此时数组为 12、20、56、91、80

 ![](https://static.vue-js.com/757f4e00-2671-11ec-a752-75723a64e8f5.png)

- 第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置，此时排序完成，变成有序数组

 ![](https://static.vue-js.com/757f4e00-2671-11ec-a752-75723a64e8f5.png)



## 二、如何实现

从上面可以看到，对于具有 `n` 个记录的无序表遍历 `n-1` 次，第` i` 次从无序表中第 `i` 个记录开始，找出后序关键字中最小的记录，然后放置在第 `i` 的位置上

直至到从第`n`个和第`n-1`个元素中选出最小的放在第`n-1`个位置

如下动画所示：

![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

用代码表示则如下：

```js
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
```

第一次内循环比较`N - 1`次，然后是`N-2`次，`N-3`次，……，最后一次内循环比较1次
共比较的次数是 `(N - 1) + (N - 2) + ... + 1`，求等差数列和，得 `(N - 1 + 1)* N / 2 = N^2 / 2`，舍去最高项系数，其时间复杂度为 `O(N^2)`

从上述也可以看到，选择排序是一种稳定的排序





## 三、应用场景

和冒泡排序一致，相比其它排序算法，这也是一个相对较高的时间复杂度，一般情况不推荐使用

但是我们还是要掌握冒泡排序的思想及实现，这对于我们的算法思维是有很大帮助的


## 参考文献

- https://baike.baidu.com/item/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/9762418
- https://zhuanlan.zhihu.com/p/29889599
- http://data.biancheng.net/view/72.html

# QUESTION：说说你对插入排序的理解？如何实现？应用场景？

 ![](https://static.vue-js.com/912adc10-267f-11ec-a752-75723a64e8f5.png)



## 一、是什么

插入排序（Insertion Sort），一般也被称为直接插入排序。对于少量元素的排序，它是一个有效、简单的算法

其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据

插入排序的工作方式像许多人排序一手扑克牌，开始时，我们的左手为空并且桌子上的牌面向下

然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置，该正确位置需要从右到左将它与已在手中的每张牌进行比较

例如一个无序数组 3、1、7、5、2、4、9、6，将其升序的结果则如下：

一开始有序表中无数据，直接插入3

从第二个数开始，插入一个元素1，然后和有序表中记录3比较，1<3，所以插入到记录 3 的左侧

 ![](https://static.vue-js.com/9d24f5f0-267f-11ec-a752-75723a64e8f5.png)

向有序表插入记录 7 时，同有序表中记录 3 进行比较，3<7，所以插入到记录 3 的右侧

 ![](https://static.vue-js.com/a6a954e0-267f-11ec-8e64-91fdec0f05a1.png)

向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5<7，同时 5>3，所以插入到 3 和 7 中间

 ![](https://static.vue-js.com/b1981940-267f-11ec-8e64-91fdec0f05a1.png)

照此规律，依次将无序表中的记录 4，9 和 6插入到有序表中

 ![](https://static.vue-js.com/bc2ed290-267f-11ec-a752-75723a64e8f5.png)

## 二、如何实现

将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置

如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面

![](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)

用代码表示则如下：

```js
function insertionSort(arr) {
    const len = arr.length;
    let preIndex, current;
    for (let i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
```

在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较`N- 1`次，时间复杂度为`O(n)`

最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为`O(n^2)`

通过上面了解，可以看到插入排序是一种稳定的排序方式



## 三、应用场景

插入排序时间复杂度是 O(n2)，适用于数据量不大，算法稳定性要求高，且数据局部或整体有序的数列排序

## 参考文献

- https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/7214992
- http://data.biancheng.net/view/65.html

# QUESTION：说说你对归并排序的理解？如何实现？应用场景？

 ![](https://static.vue-js.com/fa1d5720-26ac-11ec-8e64-91fdec0f05a1.png)



## 一、是什么

归并排序（Merge Sort）是建立归并操作上的一种有效，稳定的排序算法，该算法是采用分治法的一个非常典型的应用

将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序

例如对于含有 `n` 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1）

然后进行两两合并，使 `n` 个有序表变为`n/2`  个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表）

通过不断地进行两两合并，直到得到一个长度为 `n` 的有序表为止

例如对无序表{49，38，65，97，76，13，27}进行归并排序分成了分、合两部分：

如下图所示：

 ![](https://static.vue-js.com/05f14b60-26ad-11ec-a752-75723a64e8f5.png)

归并合过程中，每次得到的新的子表本身有序，所以最终得到有序表

上述分成两部分，则称为二路归并，如果分成三个部分则称为三路归并，以此类推



## 二、如何实现

关于归并排序的算法思路如下：

- 分：把数组分成两半，再递归对子数组进行分操作，直至到一个个单独数字

- 合：把两个数合成有序数组，再对有序数组进行合并操作，直到全部子数组合成一个完整的数组
  - 合并操作可以新建一个数组，用于存放排序后的数组
  - 比较两个有序数组的头部，较小者出队并且推入到上述新建的数组中
  - 如果两个数组还有值，则重复上述第二步
  - 如果只有一个数组有值，则将该数组的值出队并推入到上述新建的数组中

![](https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif)

用代码表示则如下图所示：

```js
function mergeSort(arr) {  // 采用自上而下的递归方法
    const len = arr.length;
    if(len < 2) {
        return arr;
    }
    let middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    const result = [];

    while (left.length && right.length) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());

    return result;
}
```

上述归并分成了分、合两部分，在处理分过程中递归调用两个分的操作，所花费的时间为2乘`T(n/2)`，合的操作时间复杂度则为`O(n)`，因此可以得到以下公式：

总的执行时间 = 2 × 输入长度为`n/2`的`sort`函数的执行时间 + `merge`函数的执行时间`O(n)`

当只有一个元素时，`T(1) = O(1)`

如果对`T(n) = 2 * T(n/2) + O(n) `进行左右 / n的操作，得到 `T(n) / n = (n / 2) * T(n/2) + O(1)`

现在令 `S(n) = T(n)/n`，则`S(1) = O(1)`，然后利用表达式带入得到`S(n) = S(n/2) + O(1)`

所以可以得到：`S(n) = S(n/2) + O(1) = S(n/4) + O(2) = S(n/8) + O(3) = S(n/2^k) + O(k) = S(1) + O(logn) = O(logn)`

综上可得，`T(n) = n * log(n) = nlogn`

关于归并排序的稳定性，在进行合并过程，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换，由此可见归并排序是稳定的排序算法



## 三、应用场景

在外排序中通常使用排序-归并的策略，外排序是指处理超过内存限度的数据的排序算法，通常将中间结果放在读写较慢的外存储器，如下分成两个阶段：

- 排序阶段：读入能够放进内存中的数据量，将其排序输出到临时文件，一次进行，将带排序数据组织为多个有序的临时文件
- 归并阶段：将这些临时文件组合为大的有序文件

例如，使用100m内存对900m的数据进行排序，过程如下：

- 读入100m数据内存，用常规方式排序
- 将排序后的数据写入磁盘
- 重复前两个步骤，得到9个100m的临时文件
- 将100m的内存划分为10份，将9份为输入缓冲区，第10份为输出缓冲区
- 进行九路归并排序，将结果输出到缓冲区
  - 若输出缓冲区满，将数据写到目标文件，清空缓冲区
  - 若缓冲区空，读入相应文件的下一份数据



## 参考文献

- https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/1639015
- https://chowdera.com/2021/09/20210920201630258d.html#_127
- https://juejin.cn/post/6844904007899561998

# QUESTION：说说你对快速排序的理解？如何实现？应用场景？



 ![](https://static.vue-js.com/bafae570-268a-11ec-8e64-91fdec0f05a1.png)

## 一、是什么

快速排序（Quick Sort）算法是在冒泡排序的基础上进行改进的一种算法，从名字上看就知道该排序算法的特点是快、效率高，是处理大数据最快的排序算法之一

实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小

然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就变成有序序列

例如，对无序表49，38，65，97，76，13，27，49进行快速排序，大致过程为：

- 首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49

- 将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：{27，38，13，49，65，97，76，49}

- 以 49 为支点，将整个无序表分割成了两个部分，分别为{27，38，13}和{65，97，76，49}，继续采用此种方法分别对两个子表进行排序

- 前部分子表以 27 为支点，排序后的子表为{13，27，38}，此部分已经有序；后部分子表以 65 为支点，排序后的子表为{49，65，97，76}

- 此时前半部分子表中的数据已完成排序；后部分子表继续以 65 为支点，将其分割为{49}和{97，76}，前者不需排序，后者排序后的结果为{76， 97}

- 通过以上几步的排序，最后由子表{13，27，38}、{49}、{49}、{65}、{76，97}构成有序表：{13，27，38，49，49，65，76，97}



## 二、如何实现

可以分成以下步骤：

- 分区：从数组中选择任意一个基准，所有比基准小的元素放在基准的左边，比基准大的元素放到基准的右边
- 递归：递归地对基准前后的子数组进行分区

![](https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif)

用代码表示则如下：

```js
function quickSort (arr) {
  const rec = (arr) => {
    if (arr.length <= 1) { return arr; }
    const left = [];
    const right = [];
    const mid = arr[0]; // 基准元素
    for (let i = 1; i < arr.length; i++){
      if (arr[i] < mid) {
        left.push(arr[i]);
      } else {
        right.push(arr[i]);
      }
    }
    return [...rec(left), mid, ...rec(right)]
  }
  return res(arr)
};
```

快速排序是冒泡排序的升级版，最坏情况下每一次基准元素都是数组中最小或者最大的元素，则快速排序就是冒泡排序

这种情况时间复杂度就是冒泡排序的时间复杂度：`T[n] = n * (n-1) = n^2 + n`，也就是`O(n^2)`

最好情况下是`O(nlogn)`，其中递归算法的时间复杂度公式：`T[n] = aT[n/b] + f(n)`，推导如下所示：

 ![](https://static.vue-js.com/b6019540-2b5e-11ec-8e64-91fdec0f05a1.png)

关于上述代码实现的快速排序，可以看到是稳定的


## 三、应用场景

快速排序时间复杂度为`O(nlogn)`，是目前基于比较的内部排序中被认为最好的方法，当数据过大且数据杂乱无章时，则适合采用快速排序

## 参考文献

- https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842
- https://www.cnblogs.com/l199616j/p/10597245.html

# QUESTION：说说你对二分查找的理解？如何实现？应用场景？

 ![](https://static.vue-js.com/d43ca230-2987-11ec-8e64-91fdec0f05a1.png)


## 一、是什么

在计算机科学中，二分查找算法，也称折半搜索算法，是一种在有序数组中查找某一特定元素的搜索算法

想要应用二分查找法，则这一堆数应有如下特性：

- 存储在数组中
- 有序排序

搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束

如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较

如果在某一步骤数组为空，则代表找不到

这种搜索算法每一次比较都使搜索范围缩小一半

如下图所示：

 ![](https://static.vue-js.com/e2108520-2987-11ec-a752-75723a64e8f5.png)

相比普通的顺序查找，除了数据量很少的情况下，二分查找会比顺序查找更快，区别如下所示：

![](https://pic2.zhimg.com/v2-43339b963db63b33107b56503ad6b1b5_b.gif)

## 二、如何实现

基于二分查找的实现，如果数据是有序的，并且不存在重复项，实现代码如下：

```js
function BinarySearch(arr, target) {
    if (arr.length <= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex <= highIndex) {
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target < arr[midIndex]) {
            highIndex = midIndex - 1
        } else if (target > arr[midIndex]) {
            lowIndex = midIndex + 1
        } else {
            // target === arr[midIndex]
            return midIndex
        }
    }
    return -1
}
```

如果数组中存在重复项，而我们需要找出第一个制定的值，实现则如下：

```js
function BinarySearchFirst(arr, target) {
    if (arr.length <= 1) return -1
    // 低位下标
    let lowIndex = 0
    // 高位下标
    let highIndex = arr.length - 1

    while (lowIndex <= highIndex) {
        // 中间下标
        const midIndex = Math.floor((lowIndex + highIndex) / 2)
        if (target < arr[midIndex]) {
            highIndex = midIndex - 1
        } else if (target > arr[midIndex]) {
            lowIndex = midIndex + 1
        } else {
            // 当 target 与 arr[midIndex] 相等的时候，如果 midIndex 为0或者前一个数比 target 小那么就找到了第一个等于给定值的元素，直接返回
            if (midIndex === 0 || arr[midIndex - 1] < target) return midIndex
            // 否则高位下标为中间下标减1，继续查找
            highIndex = midIndex - 1
        }
    }
    return -1
}
```

实际上，除了有序的数组可以使用，还有一种特殊的数组可以应用，那就是轮转后的有序数组

有序数组即一个有序数字以某一个数为轴，将其之前的所有数都轮转到数组的末尾所得

例如，[4, 5, 6, 7, 0, 1, 2]就是一个轮转后的有序数组

该数组的特性是存在一个分界点用来分界两个有序数组，如下：

 ![](https://static.vue-js.com/eeee2130-2987-11ec-8e64-91fdec0f05a1.png)

分界点有如下特性：

- 分界点元素 >= 第一个元素
- 分界点元素 < 第一个元素

代码实现如下：

```js
function search (nums, target) {
  // 如果为空或者是空数组的情况
  if (nums == null || !nums.length) {
    return -1;
  }
  // 搜索区间是前闭后闭
  let begin = 0,
    end = nums.length - 1;
  while (begin <= end) {
    // 下面这样写是考虑大数情况下避免溢出
    let mid = begin + ((end - begin) >> 1);
    if (nums[mid] == target) {
      return mid;
    }
    // 如果左边是有序的
    if (nums[begin] <= nums[mid]) {
      //同时target在[ nums[begin],nums[mid] ]中，那么就在这段有序区间查找
      if (nums[begin] <= target && target <= nums[mid]) {
        end = mid - 1;
      } else {
        //否则去反方向查找
        begin = mid + 1;
      }
      //如果右侧是有序的
    } else {
      //同时target在[ nums[mid],nums[end] ]中，那么就在这段有序区间查找
      if (nums[mid] <= target && target <= nums[end]) {
        begin = mid + 1;
      } else {
        end = mid - 1;
      }
    }
  }
  return -1;
};
```

对比普通的二分查找法，为了确定目标数会落在二分后的哪个部分，我们需要更多的判定条件





## 三、应用场景

二分查找法的`O(logn)`让它成为十分高效的算法。不过它的缺陷却也是比较明显，就在它的限定之上：

- 有序：我们很难保证我们的数组都是有序的
- 数组：数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)，并且数组的存储是需要连续的内存空间，不适合大数据的情况

关于二分查找的应用场景，主要如下：

- 不适合数据量太小的数列；数列太小，直接顺序遍历说不定更快，也更简单
- 每次元素与元素的比较是比较耗时的，这个比较操作耗时占整个遍历算法时间的大部分，那么使用二分查找就能有效减少元素比较的次数
- 不适合数据量太大的数列，二分查找作用的数据结构是顺序表，也就是数组，数组是需要连续的内存空间的，系统并不一定有这么大的连续内存空间可以使用



## 参考文献

- https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95#javascript_%E7%89%88%E6%9C%AC
- https://www.cnblogs.com/ider/archive/2012/04/01/binary_search.html


# QUESTION：说说你对分而治之、动态规划的理解？区别？



 ![](https://static.vue-js.com/298437b0-29d0-11ec-a752-75723a64e8f5.png)


## 一、分而治之

分而治之是算法设计中的一种方法，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并

关于分而治之的实现，都会经历三个步骤：

- 分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题
- 解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题
- 合并：将各子问题的解合并为原问题的解

实际上，关于分而治之的思想，我们在前面已经使用，例如归并排序的实现，同样经历了实现分而治之的三个步骤：

- 分解：把数组从中间一分为二
- 解决：递归地对两个子数组进行归并排序

- 合并：将两个字数组合并称有序数组

同样关于快速排序的实现，亦如此：

- 分：选基准，按基准把数组分成两个字数组
- 解：递归地对两个字数组进行快速排序
- 合：对两个字数组进行合并

同样二分搜索也能使用分而治之的思想去实现，代码如下：

```js
function binarySearch(arr,l,r,target){
    if(l> r){
        return -1;
    }
    let mid = l + Math.floor((r-l)/2)
    if(arr[mid] === target){
        return mid;
    }else if(arr[mid] < target ){
        return binarySearch(arr,mid + 1,r,target)
    }else{
        return binarySearch(arr,l,mid - 1,target)
    }
}
```



## 二、动态规划

动态规划，同样是算法设计中的一种方法，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法

常常适用于有重叠子问题和最优子结构性质的问题

简单来说，动态规划其实就是，给定一个问题，我们把它拆成一个个子问题，直到子问题可以直接解决

然后呢，把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。

一般这些子问题很相似，可以通过函数关系式递推出来，例如斐波那契数列，我们可以得到公式：当 n 大于 2的时候，F(n) =  F(n-1) + F(n-2) ，

f(10)= f(9)+f(8),f(9) = f(8) + f(7)...是重叠子问题，当n = 1、2的时候，对应的值为2，这时候就通过可以使用一个数组记录每一步计算的结果，以此类推，减少不必要的重复计算



### 适用场景

如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划

比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问题等等，都是动态规划的经典应用场景

关于动态规划题目解决的步骤，一般如下：

- 描述最优解的结构
- 递归定义最优解的值
- 按自底向上的方式计算最优解的值
- 由计算出的结果构造一个最优解


## 三、区别

动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解

与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往**不是互相独立**的，而分而治之的子问题是相互独立的

若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次

如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间

综上，可得：

- 动态规划：有最优子结构和重叠子问题

- 分而治之：各子问题独立



## 参考文献

- https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408
- https://juejin.cn/post/6951922898638471181


# QUESTION：说说你对贪心算法、回溯算法的理解？应用场景？



 ![](https://static.vue-js.com/1d49eae0-2e8e-11ec-a752-75723a64e8f5.png)

## 一、贪心算法

贪心算法，又称贪婪算法，是算法设计中的一种思想

其期待每一个阶段都是局部最优的选择，从而达到全局最优，但是结果并不一定是最优的

举个零钱兑换的例子，如果你有1元、2元、5元的钱币数张，用于兑换一定的金额，但是要求兑换的钱币张数最少

如果现在你要兑换11元，按照贪心算法的思想，先选择面额最大的5元钱币进行兑换，那么就得到11 = 5 + 5 + 1 的选择，这种情况是最优的

但是如果你手上钱币的面额为1、3、4，想要兑换6元，按照贪心算法的思路，我们会 6 = 4 + 1 + 1这样选择，这种情况结果就不是最优的选择

从上面例子可以看到，贪心算法存在一些弊端，使用到贪心算法的场景，都会存在一个特性：

一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法

至于是否选择贪心算法，主要看是否有如下两大特性：

-  贪心选择：当某一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次做出的选择可以依赖以前做出的选择，但不需要依赖后面需要做出的选择
- 最优子结构：如果一个问题的最优解包含其子问题的最优解，则此问题具备最优子结构的性质。问题的最优子结构性质是该问题是否可以用贪心算法求解的关键所在



## 二、回溯算法

回溯算法，也是算法设计中的一种思想，是一种渐进式寻找并构建问题解决方式的策略

回溯算法会先从一个可能的工作开始解决问题，如果不行，就回溯并选择另一个动作，知道将问题解决

使用回溯算法的问题，有如下特性：

- 有很多路，例如一个矩阵的方向或者树的路径
- 在这些的路里面，有死路也有生路，思路即不符合题目要求的路，生路则符合
- 通常使用递归来模拟所有的路

常见的伪代码如下：

```js
result = []
function backtrack(路径, 选择列表):
  if 满足结束条件:
    result.add(路径)
  return

  for 选择 of 选择列表:
    做选择
    backtrack(路径, 选择列表)
    撤销选择
```

重点解决三个问题：

- 路径：也就是已经做出的选择
- 选择列表
- 结束条件



例如经典使用回溯算法为解决全排列的问题，如下：

一个不含重复数字的数组 `nums` ，我们要返回其所有可能的全排列，解决这个问题的思路是：

- 用递归模拟所有的情况
- 遇到包含重复元素的情况则回溯
- 收集到所有到达递归终点的情况，并返回、

 ![](https://static.vue-js.com/2a030f00-2e8e-11ec-8e64-91fdec0f05a1.png)

用代码表示则如下：

```js
var permute = function(nums) {
    const res = [], path = [];
    backtracking(nums, nums.length, []);
    return res;

    function backtracking(n, k, used) {
        if(path.length === k) {
            res.push(Array.from(path));
            return;
        }
        for (let i = 0; i < k; i++ ) {
            if(used[i]) continue;
            path.push(n[i]);
            used[i] = true; // 同支
            backtracking(n, k, used);
            path.pop();
            used[i] = false;
        }
    }
};
```





## 三、总结

前面也初步了解到分而治之、动态规划，现在再了解到贪心算法、回溯算法

其中关于分而治之、动态规划、贪心策略三者的求解思路如下：

 ![](https://static.vue-js.com/504b5230-2e8e-11ec-8e64-91fdec0f05a1.png)

其中三者对应的经典问题如下图：

 ![](https://static.vue-js.com/62cdc910-2e8e-11ec-8e64-91fdec0f05a1.png)



## 参考文献

- https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95
- https://leetcode-cn.com/problems/permutations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-mfrp/
- https://cloud.tencent.com/developer/article/1767046