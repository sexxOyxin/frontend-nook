# git
# QUESTION：说说你对版本管理的理解？常用的版本管理工具有哪些？



 ![](https://static.vue-js.com/f0e8a2d0-f5ac-11eb-ab90-d9ae814b240d.png)

## 一、是什么

版本控制（Version control），是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程。此外，版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步

透过文档控制，能记录任何工程项目内各个模块的改动历程，并为每次改动编上序号

一种简单的版本控制形式如下：赋给图的初版一个版本等级“A”。当做了第一次改变后，版本等级改为“B”，以此类推

版本控制能提供项目的设计者，将设计恢复到之前任一状态的选择权

简言之，你的修改只要提到到版本控制系统，基本都可以找回，版本控制系统就像一台时光机器，可以让你回到任何一个时间点





## 二、有哪些

版本控制系统在当今的软件开发中，被认为是理所当然的配备工具之一，根据类别可以分成：

- 本地版本控制系统
- 集中式版本控制系统
- 分布式版本控制系统







### 本地版本控制系统

结构如下图所示：

 ![](https://static.vue-js.com/c545ded0-f5ad-11eb-ab90-d9ae814b240d.png)

优点：

- 简单，很多系统中都有内置
- 适合管理文本，如系统配置

缺点：

- 其不支持远程操作，因此并不适合多人版本开发



### 集中式版本控制系统

结构如下图所示：

 ![](https://static.vue-js.com/8b4b3040-f5ad-11eb-85f6-6fac77c0c9b3.png)

优点：

- 适合多人团队协作开发
- 代码集中化管理

缺点：

- 单点故障
- 必须联网，无法单机工作





代表工具有`SVN`、`CVS`：

### SVN

`TortoiseSVN`是一款非常易于使用的跨平台的 版本控制/版本控制/源代码控制软件



### CVS

`CVS`是版本控制系统，是源配置管理（SCM）的重要组成部分。使用它，您可以记录源文件和文档的历史记录

老牌的版本控制系统，它是基于客户端/服务器的行为使得其可容纳多用户，构成网络也很方便

这一特性使得`CVS`成为位于不同地点的人同时处理数据文件（特别是程序的源代码）时的首选





#### 分布式版本控制系统

结构如下图：

 ![](https://static.vue-js.com/4301a260-f5ad-11eb-85f6-6fac77c0c9b3.png)



优点：

- 适合多人团队协作开发
- 代码集中化管理
- 可以离线工作
- 每个计算机都是一个完整仓库

分布式版本管理系统每个计算机都有一个完整的仓库，可本地提交，可以做到离线工作，则不用像集中管理那样因为断网情况而无法工作



代表工具为`Git`、`HG`：

### Git

`Git`是目前世界上最先进的分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有事务

特性：易于学习，占用内存小，具有闪电般快速的性能

使用`Git`和`Gitlab`搭建版本控制环境是现在互联网公司最流行的版本控制方式



### HG

`Mercurial`是一个免费的分布式源代码管理工具。它可以有效地处理任何规模的项目，并提供简单直观的界面

`Mercurial `是一种轻量级分布式版本控制系统，采用 `Python `语言实现，易于学习和使用，扩展性强





## 三、总结

版本控制系统的优点如下：

- 记录文件所有历史变化，这是版本控制系统的基本能力
- 随时恢复到任意时间点，历史记录功能使我们不怕改错代码了
- 支持多功能并行开发，通常版本控制系统都支持分支，保证了并行开发的可行
- 多人协作并行开发，对于多人协作项目，支持多人协作开发的版本管理将事半功倍



## 参考文献

- https://pm.readthedocs.io/vcs/understanding.html
- https://zh.wikipedia.org/wiki/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6

# QUESTION：说说你对Git的理解？



 ![](https://static.vue-js.com/213eba50-f79c-11eb-bc6f-3f06e1491664.png)

## 一、是什么

git，是一个分布式版本控制软件，最初目的是为更好地管理`Linux`内核开发而设计

分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复

 ![](https://static.vue-js.com/29240f40-f79c-11eb-991d-334fd31f0201.png)

项目开始，只有一个原始版仓库，别的机器可以`clone`这个原始版本库，那么所有`clone`的机器，它们的版本库其实都是一样的，并没有主次之分

所以在实现团队协作的时候，只要有一台电脑充当服务器的角色，其他每个人都从这个“服务器”仓库`clone`一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交

`github`实际就可以充当这个服务器角色，其是一个开源协作社区，提供`Git`仓库托管服务，既可以让别人参与你的开源项目，也可以参与别人的开源项目



## 二、工作原理

当我们通过`git init`创建或者`git clone`一个项目的时候，项目目录会隐藏一个`.git`子目录，其作用是用来跟踪管理版本库的

`Git` 中所有数据在存储前都计算校验和，然后以校验和来引用，所以在我们修改或者删除文件的时候，`git`能够知道

`Git `用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）， 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来，如下：

```text
24b9da6552252987aa493b52f8696cd6d3b00373
```

当我们修改文件的时候，`git`就会修改文件的状态，可以通过`git status`进行查询，状态情况如下：

- 已修改（modified）：表示修改了文件，但还没保存到数据库中。
- 已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
- 已提交（committed）：表示数据已经安全的保存在本地数据库中。

文件状态对应的，不同状态的文件在` Git `中处于不同的工作区域，主要分成了四部分：

- 工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本
- 暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中
- 本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库
- 远程仓库：远程的仓库，如 github

 ![](https://static.vue-js.com/3273c9a0-f79c-11eb-bc6f-3f06e1491664.png)



## 三、命令

从上图可以看到，`git`日常简单的使用就只有上图6个命令：

- add
- commit
- push
- pull
- clone
- checkout

但实际上还有很多命令，如果想要熟练使用，还有60个多命令，通过这些命令的配合使用，能够提高个人工作效率和团队协助能力



## 参考文献

- https://zh.wikipedia.org/wiki/Git
- https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html

# QUESTION：说说Git中 fork, clone,branch这三个概念，有什么区别?

 ![](https://static.vue-js.com/9c4eb9a0-f7ad-11eb-bc6f-3f06e1491664.png)



## 一、是什么

### fork

`fork`，英语翻译过来就是叉子，动词形式则是分叉，如下图，从左到右，一条直线变成多条直线

 ![](https://static.vue-js.com/ad04ade0-f7ad-11eb-991d-334fd31f0201.png)

转到`git`仓库中，`fork`则可以代表分叉、克隆 出一个（仓库的）新拷贝

 ![](https://static.vue-js.com/b4b31450-f7ad-11eb-991d-334fd31f0201.png)

包含了原来的仓库（即upstream repository，上游仓库）所有内容，如分支、Tag、提交

如果想将你的修改合并到原项目中时，可以通过的 Pull Request 把你的提交贡献回 原仓库

### clone

`clone`，译为克隆，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓

执行`clone`命令后，会在当前目录下创建一个名为`xxx`的目录，并在这个目录下初始化一个 `.git` 文件夹，然后从中读取最新版本的文件的拷贝

默认配置下远程 `Git` 仓库中的每一个文件的每一个版本都将被拉取下来

### branch

`branch`，译为分支，其作用简单而言就是开启另一个分支， 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线

` Git` 处理分支的方式十分轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷

在我们开发中，默认只有一条`master`分支，如下图所示：

 ![](https://static.vue-js.com/7fa8e9c0-f923-11eb-991d-334fd31f0201.png)

通过`git branch `可以创建一个分支，但并不会自动切换到新分支中去

 ![](https://static.vue-js.com/89efd560-f923-11eb-bc6f-3f06e1491664.png)

通过`git checkout`可以切换到另一个`testing`分支

 ![](https://static.vue-js.com/91d1cef0-f923-11eb-bc6f-3f06e1491664.png)


## 二、如何使用

### fork

当你在`github`发现感兴趣开源项目的时候，可以通过点击`github`仓库中右上角`fork`标识的按钮，如下图：

 ![](https://static.vue-js.com/bc4c4510-f7ad-11eb-991d-334fd31f0201.png)

点击这个操作后会将这个仓库的文件、提交历史、issues和其余东西的仓库复制到自己的`github`仓库中，而你本地仓库是不会存在任何更改

然后你就可以通过`git clone`对你这个复制的远程仓库进行克隆

后续更改任何东西都可以在本地完成，如`git add`、`git commit`一系列的操作，然后通过`push`命令推到自己的远程仓库

如果希望对方接受你的修改，可以通过发送`pull requests`给对方，如果对方接受。则会将你的修改内容更新到仓库中

 ![](https://static.vue-js.com/c5265a40-f7ad-11eb-991d-334fd31f0201.png)

整体流程如下图：

 ![](https://static.vue-js.com/ced8ce10-f7ad-11eb-bc6f-3f06e1491664.png)


### clone

在`github`中，开源项目右侧存在`code`按钮，点击后则会显示开源项目`url`信息，如下图所示：

 ![](https://static.vue-js.com/d8685090-f7ad-11eb-bc6f-3f06e1491664.png)

通过`git clone xxx`则能完成远程项目的下载


### branch

可通过`git branch`进行查看当前的分支状态，

如果给了`--list`，或者没有非选项参数，现有的分支将被列出；当前的分支将以绿色突出显示，并标有星号

以及通过`git branch`创建一个新的分支出来


## 三、区别

其三者区别如下：

- fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”
- clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓
- branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支

## 参考文献

- https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库
- https://git-scm.com/book/zh/v2/Git-分支-分支简介


# QUESTION：说说Git常用的命令有哪些？

 ![](https://static.vue-js.com/f66b3290-f7af-11eb-bc6f-3f06e1491664.png)

## 一、前言

`git `的操作可以通过命令的形式如执行，日常使用就如下图6个命令即可

 ![](https://static.vue-js.com/fe150520-f7af-11eb-991d-334fd31f0201.png)

实际上，如果想要熟练使用，超过60多个命令需要了解，下面则介绍下常见的的`git `命令



## 二、有哪些





## 配置

`Git `自带一个 `git config` 的工具来帮助设置控制 `Git `外观和行为的配置变量，在我们安装完`git`之后，第一件事就是设置你的用户名和邮件地址

后续每一个提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改

设置提交代码时的用户信息命令如下：

- git config [--global] user.name "[name]"
- git config [--global] user.email "[email address]"





### 启动

一个`git`项目的初始有两个途径，分别是：

- git init [project-name]：创建或在当前目录初始化一个git代码库
- git clone url：下载一个项目和它的整个代码历史



### 日常基本操作

在日常工作中，代码常用的基本操作如下：

- git init 初始化仓库，默认为 master 分支
- git add . 提交全部文件修改到缓存区
- git add <具体某个文件路径+全名> 提交某些文件到缓存区
- git diff  查看当前代码 add后，会 add 哪些内容
- git diff --staged查看现在 commit 提交后，会提交哪些内容
- git status 查看当前分支状态
- git pull <远程仓库名> <远程分支名> 拉取远程仓库的分支与本地当前分支合并
- git pull <远程仓库名> <远程分支名>:<本地分支名> 拉取远程仓库的分支与本地某个分支合并
- git commit -m "<注释>" 提交代码到本地仓库，并写提交注释
- git commit -v 提交时显示所有diff信息
- git commit --amend [file1] [file2] 重做上一次commit，并包括指定文件的新变化

关于提交信息的格式，可以遵循以下的规则：

- feat: 新特性，添加功能
- fix: 修改 bug
- refactor: 代码重构
- docs: 文档修改
- style: 代码格式修改, 注意不是 css 修改
- test: 测试用例修改
- chore: 其他修改, 比如构建流程, 依赖管理



### 分支操作

- git branch 查看本地所有分支
- git branch -r 查看远程所有分支
- git branch -a 查看本地和远程所有分支
- git merge <分支名> 合并分支
- git merge --abort 合并分支出现冲突时，取消合并，一切回到合并前的状态
- git branch <新分支名> 基于当前分支，新建一个分支
- git checkout --orphan <新分支名> 新建一个空分支（会保留之前分支的所有文件）
- git branch -D <分支名> 删除本地某个分支
- git push <远程库名> :<分支名> 删除远程某个分支
- git branch <新分支名称> <提交ID> 从提交历史恢复某个删掉的某个分支
- git branch -m <原分支名> <新分支名> 分支更名
- git checkout <分支名> 切换到本地某个分支
- git checkout <远程库名>/<分支名> 切换到线上某个分支
- git checkout -b <新分支名> 把基于当前分支新建分支，并切换为这个分支





### 远程同步

远程操作常见的命令：

- git fetch [remote] 下载远程仓库的所有变动
- git remote -v 显示所有远程仓库
- git pull [remote] [branch] 拉取远程仓库的分支与本地当前分支合并
- git fetch 获取线上最新版信息记录，不合并
- git push [remote] [branch] 上传本地指定分支到远程仓库
- git push [remote] --force 强行推送当前分支到远程仓库，即使有冲突
- git push [remote] --all 推送所有分支到远程仓库



### 撤销

- git checkout [file] 恢复暂存区的指定文件到工作区
- git checkout [commit] [file]  恢复某个commit的指定文件到暂存区和工作区
- git checkout . 恢复暂存区的所有文件到工作区
- git reset [commit] 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
- git reset --hard 重置暂存区与工作区，与上一次commit保持一致
- git reset [file] 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变

- git revert [commit]  后者的所有变化都将被前者抵消，并且应用到当前分支

> `reset`：真实硬性回滚，目标版本后面的提交记录全部丢失了
>
> `revert`：同样回滚，这个回滚操作相当于一个提价，目标版本后面的提交记录也全部都有



### 存储操作

你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作，但又不想提交这些杂乱的代码，这时候可以将代码进行存储

- git stash 暂时将未提交的变化移除
- git stash pop 取出储藏中最后存入的工作状态进行恢复，会删除储藏

- git stash list 查看所有储藏中的工作
- git stash apply <储藏的名称>  取出储藏中对应的工作状态进行恢复，不会删除储藏
- git stash clear 清空所有储藏中的工作
- git stash drop <储藏的名称>  删除对应的某个储藏



## 三、总结

`git`常用命令速查表如下所示：

 ![](https://static.vue-js.com/0a10f3c0-f7b0-11eb-991d-334fd31f0201.png)



## 参考文献

- https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html

- https://segmentfault.com/a/1190000017875714

# QUESTION：说说Git 中 HEAD、工作树和索引之间的区别？

 ![](https://static.vue-js.com/2de056a0-fa40-11eb-991d-334fd31f0201.png)

## 一、HEAD

在`git`中，可以存在很多分支，其本质上是一个指向`commit`对象的可变指针，而`Head`是一个特别的指针，是一个指向你正在工作中的本地分支的指针

简单来讲，就是你现在在哪儿，HEAD 就指向哪儿

例如当前我们处于`master`分支，所以`HEAD`这个指针指向了`master`分支指针

 ![](https://static.vue-js.com/36cb0da0-fa40-11eb-991d-334fd31f0201.png)

然后通过调用`git checkout test`切换到`test`分支，那么`HEAD`则指向`test`分支，如下图：

 ![](https://static.vue-js.com/3e86ba80-fa40-11eb-991d-334fd31f0201.png)

但我们在`test`分支再一次`commit`信息的时候，`HEAD`指针仍然指向了`test`分支指针，而`test`分支指针已经指向了最新创建的提交，如下图：

 ![](https://static.vue-js.com/439839b0-fa66-11eb-991d-334fd31f0201.png)

这个`HEAD`存储的位置就在`.git/HEAD`目录中，查看信息可以看到`HEAD`指向了另一个文件

```cmd
$ cat .git/HEAD
ref: refs/heads/master

$ cat .git/refs/heads/master
7406a10efcc169bbab17827aeda189aa20376f7f
```

这个文件的内容是一串哈希码，而这个哈希码正是`master`分支上最新的提交所对应的哈希码

所以，当我们切换分支的时候，`HEAD`指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交

所以，HEAD指针 ——–> 分支指针 ——–> 最新提交



## 二、工作树和索引

在`Git`管理下，大家实际操作的目录被称为工作树，也就是工作区域

在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域

 ![](https://static.vue-js.com/46e5ac40-fa40-11eb-bc6f-3f06e1491664.png)

`Git`在执行提交的时候，不是直接将工作树的状态保存到数据库，而是将设置在中间索引区域的状态保存到数据库

因此，要提交文件，首先需要把文件加入到索引区域中。

所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交



## 三、区别

从所在的位置来看：

- HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交

- 工作树是查看和编辑的（源）文件的实际内容

- 索引是放置你想要提交给 git仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过git commit 则将索引区域的文件提交到 git 仓库中




## 参考文献

- https://backlog.com/git-tutorial/cn/intro/intro1_4.html
- https://juejin.cn/post/6844903598522908686
- https://www.zsythink.net/archives/3412


# QUESTION：说说对git pull 和 git fetch 的理解？有什么区别？

 ![](https://static.vue-js.com/cc90c050-fac2-11eb-991d-334fd31f0201.png)

## 一、是什么
先回顾两个命令的定义
- git fetch 命令用于从另一个存储库下载对象和引用
- git pull 命令用于从另一个存储库或本地分支获取并集成(整合)

再来看一次`git`的工作流程图，如下所示：

 ![](https://static.vue-js.com/d523ba60-fac2-11eb-991d-334fd31f0201.png)

可以看到，`git fetch`是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中

而`git pull` 则是将远程主机的最新内容拉下来后直接合并，即：`git pull = git fetch + git merge`，这样可能会产生冲突，需要手动解决

在我们本地的`git`文件中对应也存储了`git`本地仓库分支的`commit ID `和 跟踪的远程分支的`commit ID`，对应文件如下：

-  .git/refs/head/[本地分支]
-  .git/refs/remotes/[正在跟踪的分支]

使用 `git fetch`更新代码，本地的库中`master`的`commitID`不变

但是与`git`上面关联的那个`orign/master`的`commit ID`发生改变

这时候我们本地相当于存储了两个代码的版本号，我们还要通过`merge`去合并这两个不同的代码版本

 ![](https://static.vue-js.com/fd23ff70-fb12-11eb-bc6f-3f06e1491664.png)

也就是`fetch`的时候本地的`master`没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地`merge`合并这两个版本号的代码

相比之下，使用`git pull`就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：

 ![](https://static.vue-js.com/091b8140-fb13-11eb-bc6f-3f06e1491664.png)





## 二、用法

一般远端仓库里有新的内容更新，当我们需要把新内容下载的时候，就使用到`git pull`或者`git fetch`命令

### fetch

用法如下：

```cmd
git fetch <远程主机名> <远程分支名>:<本地分支名>
```

例如从远程的`origin`仓库的`master`分支下载代码到本地并新建一个`temp`分支

```cmd
git fetch origin master:temp
```

如果上述没有冒号，则表示将远程`origin`仓库的`master`分支拉取下来到本地当前分支

这里`git fetch`不会进行合并，执行后需要手动执行`git merge`合并，如下：

```cmd
git merge temp
```



### pull

两者的用法十分相似，`pull`用法如下：

```cmd
git pull <远程主机名> <远程分支名>:<本地分支名>
```

例如将远程主机`origin`的`master`分支拉取过来，与本地的`branchtest`分支合并，命令如下：

```cmd
git pull origin master:branchtest
```

同样如果上述没有冒号，则表示将远程`origin`仓库的`master`分支拉取下来与本地当前分支合并



## 三、区别

相同点：

- 在作用上他们的功能是大致相同的，都是起到了更新代码的作用

不同点：

- git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull = git fetch + git merge
- 相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并



## 参考文献

- https://zhuanlan.zhihu.com/p/123370920
- https://segmentfault.com/a/1190000017030384
- https://juejin.cn/post/6844903921794859021


# QUESTION：说说你对git stash 的理解？应用场景？

 ![](https://static.vue-js.com/83ddf210-fd6f-11eb-bc6f-3f06e1491664.png)



## 一、是什么

stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上

后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码

默认情况下，`git stash`会缓存下列状态的文件：

- 添加到暂存区的修改（staged changes）
- Git跟踪的但并未添加到暂存区的修改（unstaged changes）

但以下状态的文件不会缓存：

- 在工作目录中新的文件（untracked files）
- 被忽略的文件（ignored files）

如果想要上述的文件都被缓存，可以使用`-u`或者`--include-untracked`可以工作目录新的文件，使用`-a`或者`--all`命令可以当前目录下的所有修改



## 二、如何使用

关于`git stash`常见的命令如下：

- git stash
- git stash save

- git stash list
- git stash pop
- git stash apply
- git stash show

- git stash drop
- git stash clear



### git stash

保存当前工作进度，会把暂存区和工作区的改动保存起来



### git stash save

`git stash save`可以用于存储修改.并且将`git`的工作状态切回到`HEAD`也就是上一次合法提交上

如果给定具体的文件路径,`git stash`只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：

- --keep-index 或者 -k 只会存储为加入 git 管理的文件

- --include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态
- -a 或者 --all 命令可以当前目录下的所有修改，包括被 git 忽略的文件



### git stash list

显示保存进度的列表。也就意味着，`git stash`命令可以多次执行，当多次使用`git stash`命令后，栈里会充满未提交的代码，如下：

 ![](https://static.vue-js.com/50216dd0-fccf-11eb-bc6f-3f06e1491664.png)

其中，`stash@{0}`、`stash@{1}`就是当前`stash`的名称



### git stash pop

`git stash pop` 从栈中读取最近一次保存的内容，也就是栈顶的`stash`会恢复到工作区

也可以通过 `git stash pop` + `stash`名字执行恢复哪个`stash`恢复到当前目录

如果从`stash`中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突





### git stash apply

将堆栈中的内容应用到当前目录，不同于`git stash pop`，该命令不会将内容从堆栈中删除

也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况

同样，可以通过`git stash apply` + `stash`名字执行恢复哪个`stash`恢复到当前目录







### git stash show

查看堆栈中最新保存的`stash`和当前目录的差异

通过使用`git stash show -p`查看详细的不同

通过使用`git stash show stash@{1}`查看指定的`stash`和当前目录差异

 ![](https://static.vue-js.com/458620a0-fccf-11eb-bc6f-3f06e1491664.png)



### git stash drop

`git stash drop` + `stash`名称表示从堆栈中移除某个指定的stash



### git stash clear

删除所有存储的进度



## 三、应用场景

当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情

但是你创建一次未完成的代码的`commit`提交，这时候就可以使用`git stash`

例如以下场景：

当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过`git pull`解决

但是如果可能发生冲突怎么办.直接`git pull`会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：

- git stash
- git pull
- git stash pop

或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用`git stash`缓存当前区域的代码

- git stash：保存开发到一半的代码
- git commit -m '修改问题'
- git stash pop：将代码追加到最新的提交之后

# QUESTION：说说你对git rebase 和 git merge的理解？区别？



 ![](https://static.vue-js.com/77590970-fdd4-11eb-bc6f-3f06e1491664.png)

## 一、是什么

在使用 `git` 进行版本管理的项目中，当完成一个特性的开发并将其合并到 `master` 分支时，会有两种方式：

- git merge
- git rebase

`git rebase` 与 `git merge`都有相同的作用，都是将一个分支的提交合并到另一分支上，但是在原理上却不相同



用法上两者也十分的简单：

### git merge

将当前分支合并到指定分支，命令用法如下：

```cmd
git merge xxx
```



### git rebase

将当前分支移植到指定分支或指定`commit`之上，用法如下：

```cmd
git rebase -i <commit>
```

常见的参数有`--continue`，用于解决冲突之后，继续执行`rebase`

```cmd
git rebase --continue
```





## 二、分析

### git merge

通过`git merge`将当前分支与`xxx`分支合并，产生的新的`commit`对象有两个父节点

如果“指定分支”本身是当前分支的一个直接子节点，则会产生快照合并

举个例子，`bugfix`分支是从`master`分支分叉出来的，如下所示：

 ![](https://static.vue-js.com/88410a30-fdd4-11eb-991d-334fd31f0201.png)

合并` bugfix`分支到`master`分支时，如果`master`分支的状态没有被更改过，即 `bugfix`分支的历史记录包含`master`分支所有的历史记录

所以通过把`master`分支的位置移动到`bugfix`的最新分支上，就完成合并

如果`master`分支的历史记录在创建`bugfix`分支后又有新的提交，如下情况：

 ![](https://static.vue-js.com/929eb220-fdd4-11eb-991d-334fd31f0201.png)

这时候使用`git merge`的时候，会生成一个新的提交，并且`master`分支的`HEAD`会移动到新的分支上，如下：

 ![](https://static.vue-js.com/9fdfa3e0-fdd4-11eb-991d-334fd31f0201.png)



从上面可以看到，会把两个分支的最新快照以及二者最近的共同祖先进行三方合并，合并的结果是生成一个新的快照



### git rebase

同样，`master`分支的历史记录在创建`bugfix`分支后又有新的提交，如下情况：

 ![](https://static.vue-js.com/ab2d5120-fdd4-11eb-bc6f-3f06e1491664.png)

通过`git rebase`，会变成如下情况：

 ![](https://static.vue-js.com/b72aed70-fdd4-11eb-991d-334fd31f0201.png)

在移交过程中，如果发生冲突，需要修改各自的冲突，如下：

 ![](https://static.vue-js.com/c9ba0e80-fdd4-11eb-bc6f-3f06e1491664.png)

`rebase`之后，`master`的`HEAD`位置不变。因此，要合并`master`分支和`bugfix`分支

 ![](https://static.vue-js.com/dc660660-fdd4-11eb-991d-334fd31f0201.png)

从上面可以看到，`rebase`会找到不同的分支的最近共同祖先，如上图的`B`

然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件（老的提交`X`和`Y`也没有被销毁，只是简单地不能再被访问或者使用）

然后将当前分支指向目标最新位置`D`, 然后将之前另存为临时文件的修改依序应用





## 三、区别

从上面可以看到，`merge`和`rebasea`都是合并历史记录，但是各自特性不同：

### merge

通过`merge`合并分支会新增一个`merge commit`，然后将两个分支的历史联系起来

其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂



### rebase

`rebase `会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交

主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 ` git merge `所需的不必要的合并提交


## 参考文献

- https://zhuanlan.zhihu.com/p/361182707
- https://yuweijun.github.io/git-zh/1-git-branching.html#_rebasing
- https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html


# QUESTION：说说 git 发生冲突的场景？如何解决？

 ![](https://static.vue-js.com/8aeccc40-fdb3-11eb-bc6f-3f06e1491664.png)

## 一、是什么

一般情况下，出现分支的场景有如下：

- 多个分支代码合并到一个分支时
- 多个分支向同一个远端分支推送

具体情况就是，多个分支修改了同一个文件（任何地方）或者多个分支修改了同一个文件的名称

如果两个分支中分别修改了不同文件中的部分，是不会产生冲突，直接合并即可

应用在命令中，就是`push`、`pull`、`stash`、`rebase`等命令下都有可能产生冲突情况，从本质上来讲，都是`merge`和`patch`（应用补丁）时产生冲突



## 二、分析

在本地主分值`master`创建一个`a.txt`文件，文件起始位置写上`master commit`，如下：

 ![](https://static.vue-js.com/959ade20-fdb3-11eb-991d-334fd31f0201.png)

然后提交到仓库：

- git add a.txt
- git commit -m 'master first commit'

创建一个新的分支`featurel1`分支，并进行切换，如下：

```cmd
git checkout -b featurel1
```

然后修改`a.txt`文件首行文字为 `featurel commit`，然后添加到暂存区，并开始进行提交到仓库：

- git add a.txt
- git commit -m 'featurel  first change'

然后通过`git checkout master`切换到主分支，通过`git merge`进行合并，发现不会冲突

此时`a.txt`文件的内容变成`featurel commit`，没有出现冲突情况，这是因为`git`在内部发生了快速合并

> 如果当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作
>
> git 不创建任何新的提交(commit)，只是将当前分支指向合并进来的分支

如果此时切换到`featurel`分支，将文件的内容修改成`featrue second commit`，然后提交到本地仓库

然后切换到主分支，如果此时在`a.txt`文件再次修改，修改成`mastet second commit`，然后再次提交到本地仓库

此时，`master`分支和`feature1`分支各自都分别有新的提交，变成了下图所示：

 ![](https://static.vue-js.com/a05488c0-fdb3-11eb-991d-334fd31f0201.png)

这种情况下，无法执行快速合并，只能试图把各自的修改合并起来，但这种合并就可能会有冲突

现在通过`git merge featurel`进行分支合并，如下所示：

 ![](https://static.vue-js.com/b0991d90-fdb3-11eb-bc6f-3f06e1491664.png)

从冲突信息可以看到，`a.txt`发生冲突，必须手动解决冲突之后再提交

而`git status`同样可以告知我们冲突的文件：

 ![](https://static.vue-js.com/c5823430-fdb3-11eb-991d-334fd31f0201.png)

打开`a.txt`文件，可以看到如下内容：

 ![](https://static.vue-js.com/ce7a0a90-fdb3-11eb-bc6f-3f06e1491664.png)

`git`用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容：

- <<<<<<< 和 ======= 之间的区域就是当前更改的内容
- ======= 和 >>>>>>> 之间的区域就是传入进来更改的内容

现在要做的事情就是将冲突的内容进行更改，对每个文件使用 `git add` 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，`Git `就会将它们标记为冲突已解决然后再提交：

- git add a.txt
- git commit -m "conflict fixed"

此时`master`分支和`feature1`分支变成了下图所示：

 ![](https://static.vue-js.com/d7421e60-fdb3-11eb-bc6f-3f06e1491664.png)

使用`git log`命令可以看到合并的信息：

 ![](https://static.vue-js.com/e0dfd1b0-fdb3-11eb-991d-334fd31f0201.png)





## 三、总结

当`Git`无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成

解决冲突就是把`Git`合并失败的文件手动编辑为我们希望的内容，再提交



## 参考文献

- https://www.liaoxuefeng.com/wiki/896043488029600/900004111093344

# QUESTION：说说你对git reset 和 git revert 的理解？区别？

![](https://static.vue-js.com/046b4440-ff74-11eb-bc6f-3f06e1491664.png)


## 一、是什么

### git reset

`reset`用于回退版本，可以遗弃不再使用的提交

执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容

 ![](https://static.vue-js.com/ab4d0c00-ff72-11eb-bc6f-3f06e1491664.png)



### git revert

在当前提交后面，新增一次提交，抵消掉上一次提交导致的所有变化，不会改变过去的历史，主要是用于安全地取消过去发布的提交

 ![](https://static.vue-js.com/bd12c290-ff72-11eb-991d-334fd31f0201.png)


## 二、如何用

### git reset

当没有指定`ID`的时候，默认使用`HEAD`，如果指定`ID`，那么就是基于指向`ID`去变动暂存区或工作区的内容

```cmd
// 没有指定ID, 暂存区的内容会被当前ID版本号的内容覆盖，工作区不变
git reset

// 指定ID，暂存区的内容会被指定ID版本号的内容覆盖，工作区不变
git reset <ID>
```

日志`ID`可以通过查询，可以`git log`进行查询，如下：

```cmd
commit a7700083ace1204ccdff9f71631fb34c9913f7c5 (HEAD -> master)
Author: linguanghui <linguanghui@baidu.com>
Date:   Tue Aug 17 22:34:40 2021 +0800

    second commit

commit e31118663ce66717edd8a179688a7f3dde5a9393
Author: linguanghui <linguanghui@baidu.com>
Date:   Tue Aug 17 22:20:01 2021 +0800

    first commit
```

常见命令如下：

- --mixed（默认）：默认的时候，只有暂存区变化

- --hard参数：如果使用 --hard 参数，那么工作区也会变化

- --soft：如果使用 --soft 参数，那么暂存区和工作区都不会变化

 ![](https://static.vue-js.com/225b41e0-ff73-11eb-bc6f-3f06e1491664.png)



### git revert

跟`git reset`用法基本一致，`git revert` 撤销某次操作，此次操作之前和之后的 `commit`和`history`都会保留，并且把这次撤销，作为一次最新的提交，如下：

```cmd
git revert <commit_id>
```

如果撤销前一个版本，可以通过如下命令：

```cmd
git revert HEAD
```

撤销前前一次，如下：

```cmd
git revert HEAD^
```

## 三、区别

撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，`git reset`被设计为重设本地更改

因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销

两者主要区别如下：

- git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit
- git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容
- 在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别

> git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并
>
> 但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入

- 如果回退分支的代码以后还需要的情况则使用`git revert`， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用`git reset`


## 参考文献

- https://juejin.cn/post/6844903542931587086
- https://marklodato.github.io/visual-git-guide/index-zh-cn.html#reset


# system
# QUESTION：说说你对操作系统的理解？核心概念有哪些？

![](https://static.vue-js.com/0f06bf30-008a-11ec-8e64-91fdec0f05a1.png)

## 一、是什么

操作系统（Operating System，缩写：OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石

简单来讲，操作系统就是一种复杂的软件，相当于软件管家

操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作网络与管理文件系统等基本事务，

操作系统的类型非常多样，不同机器安装的操作系统可从简单到复杂，可从移动电话的嵌入式系统到超级电脑的大型操作系统，在计算机与用户之间起接口的作用，如下图：

 ![](https://static.vue-js.com/0ad1b850-009b-11ec-8e64-91fdec0f05a1.png)

许多操作系统制造者对它涵盖范畴的定义也不尽一致，例如有些操作系统集成了图形用户界面，而有些仅使用命令行界面，将图形用户界面视为一种非必要的应用程序




## 二、核心概念

操作系统的核心概念都是对具体物理硬件的抽象，主要有如下：

- 进程（线程）：进程（线程）是操作系统对CPU的抽象
- 虚拟内存（地址空间）：虚拟内存是操作系统对物理内存的抽象
- 文件：文件是操作系统对物理磁盘的抽象
- shell：它是一个程序，可从键盘获取命令并将其提供给操作系统以执行。
- GUI ：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互
- 计算机架构(computer architecture)： 在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。它主要包括指令集、内存管理、I/O 和总线结构
- 多处理系统(Computer multitasking)：是指计算机同时运行多个程序的能力
- 程序计数器(Program counter)：程序计数器 是一个 CPU 中的寄存器，用于指示计算机在其程序序列中的位置
- 多线程(multithreading)：是指从软件或者硬件上实现多个线程并发执行的技术

- CPU 核心(core)：它是 CPU 的大脑，它接收指令，并执行计算或运算以满足这些指令。一个 CPU 可以有多个内核
- 图形处理器(Graphics Processing Unit)：又称显示核心、视觉处理器、显示芯片或绘图芯片
- 缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中

- RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器

- ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除

- 虚拟地址(virtual memory)： 虚拟内存是计算机系统内存管理的一种机制

- 驱动程序(device driver)：设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序

- USB(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范

- 地址空间(address space)：地址空间是内存中可供程序或进程使用的有效地址范

- 进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法

- 目录(directory)： 在计算机或相关设备中，一个目录或文件夹就是一个装有数字文件系统的虚拟容器

- 路径(path name)： 路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。
- 根目录(root directory)：根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /
- 工作目录(Working directory)：它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。
- 文件描述符(file descriptor)： 文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念
- 客户端(clients)：客户端是访问服务器提供的服务的计算机硬件或软件。
- 服务端(servers)： 在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备



## 三、总结

- 操作系统是管理计算机硬件与软件资源的程序，是计算机的基石
- 操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源
- 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项
- 操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性



## 参考文献

- https://www.cnblogs.com/cxuanBlog/p/13297199.html
- https://www.cnblogs.com/cxuanblog/p/12607608.html
- https://www.anvilliu.com/2021/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/

# QUESTION：说说什么是进程？什么是线程？区别？



![](https://static.vue-js.com/f414d8a0-02f6-11ec-a752-75723a64e8f5.png)



## 一、进程

操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位

操作系统的其他所有内容都是围绕着进程展开的，负责执行这些任务的是`CPU`

 ![](https://static.vue-js.com/3ff146b0-02f6-11ec-8e64-91fdec0f05a1.png)



进程是一种抽象的概念，从来没有统一的标准定义看，一般由程序、数据集合和进程控制块三部分组成：

- 程序用于描述进程要完成的功能，是控制进程执行的指令集
- 数据集合是程序在执行时所需要的数据和工作区
- 程序控制块，包含进程的描述信息和控制信息，是进程存在的唯一标志


## 二、线程

**线程**（thread）是操作系统能够进行**运算调度**的最小单位，其是进程中的一个执行任务（控制单元），负责当前进程中程序的执行

一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步

举个例子，假设你经营着一家物业管理公司。最初，业务量很小，事事都需要你亲力亲为。给老张家修完暖气管道，立马再去老李家换电灯泡——这叫单线程，所有的工作都得顺序执行

后来业务拓展了，你雇佣了几个工人，这样，你的物业公司就可以同时为多户人家提供服务了——这叫多线程，你是主线程

 ![](https://static.vue-js.com/63de34c0-02f6-11ec-a752-75723a64e8f5.png)

但实际上，并不是线程越多，进程的工作效率越高，这是因为在一个进程内，不管你创建了多少线程，它们总是被限定在一颗`CPU`内，或者多核`CPU`的一个核内

这意味着，多线程在宏观上是并行的，在微观上则是分时切换串行的，多线程编程无法充分发挥多核计算资源的优势

这导致使用多线程做任务并行处理时，线程数量超过一定数值后，线程越多速度反倒越慢的原因



## 三、区别

- **本质区别**：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

- **在开销方面**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小

- **所处环境**：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

- **内存分配方面**：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源

- **包含关系**：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程


举个例子：进程=火车，线程=车厢

- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）


## 参考文献

- https://zhuanlan.zhihu.com/p/106283969
- https://blog.csdn.net/ThinkWAon/article/details/102021274
- https://www.zhihu.com/question/25532384

# QUESTION：说说 linux系统下 文件操作常用的命令有哪些？

![](https://static.vue-js.com/6cb38ac0-03c1-11ec-a752-75723a64e8f5.png)


## 一、是什么
`Linux` 是一个开源的操作系统（OS），是一系列Linux内核基础上开发的操作系统的总称（常见的有Ubuntu、centos）

系统通常会包含以下4个主要部分
- 内核
- shell
- 文件系统
- 应用程序

文件系统是一个**目录树的结构**，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录

 ![](https://static.vue-js.com/b71b64c0-03c1-11ec-a752-75723a64e8f5.png)



## 二、文件操作

常见处理目录的命令如下：

- ls（英文全拼：list files）: 列出目录及文件名
- cd（英文全拼：change directory）：切换目录
- pwd（英文全拼：print work directory）：显示目前的目录
- mkdir（英文全拼：make directory）：创建一个新的目录
- rmdir（英文全拼：remove directory）：删除一个空的目录
- cp（英文全拼：copy file）: 复制文件或目录
- rm（英文全拼：remove）: 删除文件或目录
- mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称



### ls

列出目录文件，选项与参数：

- -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)
- -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)
- -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)

例如将家目录下的所有文件列出来(含属性与隐藏档)

```cmd
[root@www ~]# ls -al ~
```


### cd

切换工作目录

语法：

```cmd
 cd [相对路径或绝对路径]
```

```cmd
# 表示回到自己的家目录，亦即是 /root 这个目录
[root@www runoob]# cd ~

# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；
[root@www ~]# cd ..
```



### pwd

`pwd` 是 `Print Working Directory` 的缩写，也就是显示目前所在目录的命令。

```
[root@www ~]# pwd [-P]
```

选项与参数：

- -P ：显示出确实的路径，而非使用连结 (link) 路径





### mkdir

 创建新目录

语法：

```
mkdir [-mp] 目录名称
```

选项与参数：

- -m ：配置文件的权限
- -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来



### rmdir (删除空的目录)

语法：

```
 rmdir [-p] 目录名称
```

选项与参数：

- -p ：连同上一级『空的』目录也一起删除





### cp

即拷贝文件和目录

语法：

```cmd
cp 目标文件 拷贝文件
```

用法如下：

```cmd
cp file file_copy --> file 是目标文件，file_copy 是拷贝出来的文件
cp file one --> 把 file 文件拷贝到 one 目录下，并且文件名依然为 file
cp file one/file_copy --> 把 file 文件拷贝到 one 目录下，文件名为file_copy
cp *.txt folder --> 把当前目录下所有 txt 文件拷贝到 folder 目录下
复制代码
```

常用参数如下：

- `-r` 递归的拷贝，常用来拷贝一整个目录





### rm (移除文件或目录)

语法：

```
 rm [-fir] 文件或目录
```

选项与参数：

- -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
- -i ：互动模式，在删除前会询问使用者是否动作
- -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！



### mv (移动文件与目录，或修改名称)

语法：

```
[root@www ~]# mv [-fiu] source destination
[root@www ~]# mv [options] source1 source2 source3 .... directory
```

选项与参数：

- -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
- -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！
- -u ：若目标文件已经存在，且 source 比较新，才会升级 (update)



### ln

`Linux` 文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 `inode` 标识绑定到文件内容

`Linux` 下有两种链接类型：硬链接和软链接

#### 硬链接

使链接的两个文件共享同样文件内容，就是同样的 `inode` ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容

语法：

```cmd
# 创建 file2 为 file1 的硬链接
ln file1 file2
```



 ![](https://static.vue-js.com/c92e7800-03c1-11ec-8e64-91fdec0f05a1.png)

删除文件1不会影响删除文件2，对于硬链接来说，删除任意一方的文件，共同指向的文件内容并不会从硬盘上删除

只有同时删除了两个文件后后，它们共同指向的文件内容才会消失。



#### 软链接

类似`window`系统的快捷方式

使用方式：

```cmd
ln -s file1 file2
```

 ![](https://static.vue-js.com/d5a22eb0-03c1-11ec-8e64-91fdec0f05a1.png)其实 `file2` 只是 `file1` 的一个快捷方式，它指向的是 `file1` ，所以显示的是 `file1` 的内容，但其实 `file2` 的 `inode` 与 `file1` 并不相同

如果

删除了 `file2` 的话， `file1` 是不会受影响的，但如果删除 `file1` 的话， `file2` 就会变成死链接，因为指向的文件不见了



## 三、文件查看

常见的文件内容查看有如下：

- cat 由第一行开始显示文件内容
- less 一页一页的显示文件内容
- head 只看头几行
- tail 只看尾巴几行



### cat

由第一行开始显示文件内容

语法：

```
cat [-AbEnTv]
```

常见的选项与参数如下：

- -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！
- -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同



### less

一页一页翻动，以下实例输出/etc/man.config文件的内容：

```cmd
[root@www ~]# less /etc/man.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
....(中间省略)....
:   <== 这里可以等待你输入命令！
```

less运行时可以输入的命令有：

- 空白键  ：向下翻动一页；
- [pagedown]：向下翻动一页；
- [pageup] ：向上翻动一页；
- /字串   ：向下搜寻『字串』的功能；
- ?字串   ：向上搜寻『字串』的功能；
- n     ：重复前一个搜寻 (与 / 或 ? 有关！)
- N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)
- q     ：离开 less 这个程序



### head

取出文件前面几行

语法：

```
head [-n number] 文件
```

选项与参数：

- -n ：后面接数字，代表显示几行的意思

```cmd
[root@www ~]# head /etc/man.config
```



### tail

取出文件后面几行

语法：

```
tail [-n number] 文件
```

选项与参数：

- -n ：后面接数字，代表显示几行的意思
- -f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测



## 参考文献

- https://www.runoob.com/linux/linux-file-content-manage.html
- https://juejin.cn/post/6938385978004340744#heading-35
- https://zh.wikipedia.org/wiki/Linux


# QUESTION：说说 linux 系统下 文本编辑常用的命令有哪些？

 ![](https://static.vue-js.com/1062b8b0-049b-11ec-8e64-91fdec0f05a1.png)

## 一、是什么

`Vim`是从 `vi` 发展出来的一个文本编辑器，代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。

简单的来说， `vi` 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方

而`vim `可以说是程序开发者的一项很好用的工具



## 二、使用

基本上 vi/vim 共分为三种模式，分别是：

- 命令模式（Command mode）
- 输入模式（Insert mode）
- 底线命令模式（Last line mode）

 ![](https://static.vue-js.com/265a0080-03d6-11ec-a752-75723a64e8f5.png)



### 命令模式

`Vim` 的默认模式，在这个模式下，你不能输入文本，但是可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等



#### 移动光标

常用的命令如下：

- h 向左移动一个字符
- j 向下移动一个字符
- k 向上移动一个字符
- i 向右移动一个字符

或者使用方向键进行控制

如果想要向下移动`n`行，可通过使用 "nj" 或 "n↓" 的组合按键



#### 搜索

常见的命令如下：

- /word：向光标之下寻找一个名称为 word 的字符

- ?word：向光标之上寻找一个字符串名称为 word 的字符串
- n：代表重复前一个搜寻的动作，即再次执行上一次的操作
- N：反向进行前一个搜索动作





#### 删除、复制、粘贴

常用的命令如下：

- x：向后删除一个字符
- X：向前删除一个字符
- nc：n 为数字，连续向后删除 n 个字符
- dd：删除游标所在的那一整行
- d0：删除游标所在处，到该行的最前面一个字符
- d$删除游标所在处，到该行的最后一个字符
- ndd：除光标所在的向下 n 行
- yy：复制游标所在的那一行
- y0：复制光标所在的那个字符到该行行首的所有数据
- y$：复制光标所在的那个字符到该行行尾的所有数据
- p：已复制的数据在光标下一行贴上
- P：已复制的数据在光标上一行贴上
- nc：重复删除n行数据



### 输入模式

命令模式通过输入大小写`i`、`a`、`o`可以切换到输入模式，如下：

- i：从目前光标所在处输入
- I：在目前所在行的第一个非空格符处开始输入
- a：从目前光标所在的下一个字符处开始输入
- A：从光标所在行的最后一个字符处开始输入
- o：在目前光标所在的下一行处输入新的一行
- O：目前光标所在的上一行处输入新的一行

输入模式我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容

如果想从插入模式回到命令模式，使用按下键盘左上角的`ESC`键





### 底线命令模式

这个模式下可以运行一些命令例如“退出”，“保存”，等动作，为了进入底线命令模式，首先要进入命令模式，再按下冒号键：

常见的命令如下：

- w：将编辑的数据写入硬盘档案中
- w!：若文件属性为『只读』时，强制写入该档案
- q：未修改，直接退出
- q!：修改过但不存储
- wq：储存后离开

## 参考文献

- https://www.runoob.com/linux/linux-vim.html


# QUESTION：说说你对 linux 用户管理的理解？相关的命令有哪些？

 ![](https://static.vue-js.com/8d8d9d70-0417-11ec-8e64-91fdec0f05a1.png)



## 一、是什么

Linux是一个多用户的系统，允许使用者在系统上通过规划不同类型、不同层级的用户，并公平地分配系统资源与工作环境

而与 `Windows` 系统最大的不同， `Linux` 允许不同的用户同时登录主机，同时使用主机的资源

既然是多用户的系统，那么最常见的问题就是权限，不同的用户对于不同的文件都应该有各自的权限

例如，小 A 希望个人文件不被其他用户读取，而如果不对文件进行权限设置，共享了主机资源的小 B 也可以读取小 A 的个人文件，这是不合理的

这里面涉及到用户与用户组的概念



## 二、用户与用户组

`Linux `以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 `Linux` 作为多用户系统的可行性

从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象：

- **文件所有者**
- **用户组成员**
- **其他人**

每一个对象对某一个文件的持有权限是不同的



### 文件所有者

当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，同时排他性地拥有该文件

除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作



### 用户组

将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组

这样，这部分用户就成了与文件所有者同组的用户组成员。用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有

例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可



### 其他人

既与文件所有者没有任何联系的其他用户



### 小结

户和用户组的对应关系是：一对一、多对一、一对多或多对多：

- 一对一：某个用户可以是某个组的唯一成员
- 多对一：多个用户可以是某个唯一的组的成员，不归属其它用户组
- 一对多：某个用户可以是多个用户组的成员
- 多对多：多个用户对应多个用户组，并且几个用户可以是归属相同的组



### 拓展

当我们使用`ls -l`的时候，会列出当前目录的文件信息，如下：

```cmd
drwxr-xr-x   3  osmond   osmond    4096  05-16 13:32   nobp
```

- d：文件类型
- rwxr-xr-x：文件权限
- 3 硬链接数或目录包含的文件数
- osmond：文件所有者
- 4096：文件长度
- 05-16 13:32：文件上次修改的事件和日期
- nobp：文件名

下面主要看看文件权限分析，实际上是由9个字符组成，每3个一组：

- 第一组控制文件**所有者**的访问权限
- 第二组控制所有者**所在用户组**的其他成员的访问权限
- 第三组控制**系统其他用户**的访问权限

`-`代表当前没有，`rwx`对应代表的意思如下：

 ![](https://static.vue-js.com/9ac2cf60-0417-11ec-8e64-91fdec0f05a1.png)





### 三、用户操作



用户相关的操作有如下：

### 新增用户

`useradd` 可以用来创建新用户，简要语法为：

```text
useradd [options] [username]
```

例如：

添加一个一般用户

```
# useradd kk //添加用户kk
```

为添加的用户指定相应的用户组

```
# useradd -g root kk //添加用户kk，并指定用户所在的组为root用户组
```

创建一个系统用户

```
# useradd -r kk //创建一个系统用户kk
```

为新添加的用户指定/home目录

```
# useradd-d /home/myf kk //新添加用户kk，其home目录为/home/myf
//当用户名kk登录主机时，系统进入的默认目录为/home/myf
```



## 设置密码

 创建的用户还没有设置登录密码，需要利用`passwd`进行密码设置

```text
asswd [options] [username]
```

`option` 参数有如下：

- -d 删除密码
- -f 强迫用户下次登录时必须修改口令
- -w 口令要到期提前警告的天数
- -k 更新只能发送在过期之后
- -l 停止账号使用
- -S 显示密码信息
- -u 启用已被停止的账户
- -x 指定口令最长存活期
- -g 修改群组密码
- 指定口令最短存活期
- -i 口令过期后多少天停用账户

例如，修改用户密码

```
# passwd runoob  //设置runoob用户的密码
Enter new UNIX password:  //输入新密码，输入的密码无回显
Retype new UNIX password:  //确认密码
passwd: password updated successfully
#
```

显示账号密码信息

```
# passwd -S runoob
runoob P 05/13/2010 0 99999 7 -1
```

删除用户密码

```
# passwd -d lx138
passwd: password expiry information changed.
```



### 修改用户

`chage` 命令用来修改与用户密码相关的过期信息，如密码失效日、密码最短保留天数、失效前警告天数等

```text
chage [option] [username]
```

常见的参数有：

- -d：指定密码最后修改日期

- -E：密码到期的日期

- -l：列出用户以及密码的有效期

- -m：密码能够更改的最小天数
- -M：密码保持有效的最大天数





### 删除用户

userdel 命令用来删除用户的相关的所有数据。

```text
userdel [options] [username]
```

常见的参数有：

- -r：删除用户登入目录以及目录中所有文件

例如删除用户账号

```
# userdel hnlinux
```







用户组相关的操作如下：

### 新增用户组

`groupadd`用于创建一个新的工作组，新工作组的信息将被添加到系统文件中

```text
groupadd [options] [groupname]
```

常见的参数有如下：

- -g：指定新建工作组的 id；
- -r：创建系统工作组，系统工作组的组ID小于 500
- -K：覆盖配置文件 "/ect/login.defs"
- -o：允许添加组 ID 号不唯一的工作组
- -f,--force: 如果指定的组已经存在，此选项将失明了仅以成功状态退出

例如创建一个新的组，并添加组 ID。

```
＃groupadd －g 344 runoob
```





### 修改用户

`groupmod `命令用来修改 `group `相关的参数，例如群组识别码或者名称

```text
groupmod [options] [groupname]
```

常见的参数有：

- -g <群组识别码> 　设置欲使用的群组识别码
- -o 　重复使用群组识别码
- -n <新群组名称> 　设置欲使用的群组名

例如修改组名：

```
# groupmod -n linux linuxso
```





### 删除用户组

`groupdel` 用于删除用户组，如果该群组中仍包括某些用户，则必须先删除这些用户后，方能删除群组

```text
groupdel [groupname]
```



日常工作通常会碰到只有` root `用户才有权限执行的操作，这就需要使用用户身份切换的命令：

### su

用于变更为其他使用者的身份，除 `root` 外，需要键入该使用者的密码







### sudo

`sudo`命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行

不是所有的用户都能执行 `sudo` 命令的，而是在 `/etc/sudoers` 文件内的用户才能执行这个命令

例如`sudo`命令使用`ls`：

```
$ sudo ls
```



## 参考文献

- https://zhuanlan.zhihu.com/p/37964411
- https://zhuanlan.zhihu.com/p/105482468

# QUESTION：说说你对输入输出重定向和管道的理解？应用场景？



 ![](https://static.vue-js.com/1036dde0-0634-11ec-a752-75723a64e8f5.png)

## 一、是什么

`linux`中有三种标准输入输出，分别是`STDIN`，`STDOUT`，`STDERR`，对应的数字是0、1、2：

- STDIN 是标准输入，默认从键盘读取信息
- STDOUT 是标准输出，默认将输出结果输出至终端
- STDERR 是标准错误，默认将输出结果输出至终端

对于任何`linux`命令的执行会有下面的过程：

 ![](https://static.vue-js.com/1a57caf0-0634-11ec-8e64-91fdec0f05a1.png)

一条命令的执行需要键盘等的标准输入，命令的执行和正确或错误，其中的每一个双向箭头就是一个通道，所以数据流可以流入到文件端（**重定向或管道**）

简单来讲，重定向就是把本来要显示在终端的命令结果，输送到别的地方，分成：

- 输入重定向：流出到屏幕如果命令所需的输入不是来自键盘，而是来自指定的文件
- 输出重定向：命令的输出可以不显示在屏幕，而是写在指定的文件中

管道就是把两个命令连接起来使用，一个命令的输出作为另一个命令的输入

两者的区别在于：

- 管道触发两个子进程，执行 | 两边的程序；而重定向是在一个进程内执行。
- 管道两边都是shell命令
- 重定向符号的右边只能是Linux文件
- 重定向符号的优先级大于管道



## 二、命令

重定向常见的命令符号有：

- \> ： 输出重定向到一个文件或设备 覆盖原来的文件

> 如果该文件不存在，则新建一个文件
>
> 如果该文件已经存在，会把文件内容覆盖
>
> 这些操纵不会征用用户的确认

- \>> ：输出重定向到一个文件或设备，但是是 追加原来的文件的末尾
- <  ：用于制定命令的输入
- << ：从键盘的输入重定向为某个命令的输入

> 以逐行输入的模式（回车键进行换行）
>
> 所有输入的行都将在输入结束字符串之后发送给命令

- 2> 将一个标准错误输出重定向到一个文件或设备，会覆盖原来的文件
- 2>> 将一个标准错误输出重定向到一个文件或设备，是追加到原来的文件
- 2>&1：组合符号，将标准错误输出重定向到标准输出相同的地方

> 1就是代表标准输出

- \>& 将一个标准错误输出重定向到一个文件或设备覆盖原来的文件
- |& 将一个标准错误管道输出到另一个命令作为输入



## 三、应用场景

将当前目录的文件输出重定向到`1.txt`文件中，并且会清空原有的`1.txt`的内容

```cmd
ls -a > 1.txt
```

或者以追加的形式，重定向输入到`1.txt`中

```cmd
ls -a >> 1.txt
```

将标准错误输出到某个文件，可以如下：

```cmd
$ touch 2> 2.txt
$ cat 2.txt
touch: 缺少了文件操作数
请尝试执行 "touch --help" 来获取更多信息。
```

通过组合符号将两者结合一起，无论进程输出的信息是正确还是错误的信息，都会重定向到指定的文件里

```cmd
[root@linguanghui home]# abc &> file.txt
[root@linguanghui home]# cat file.txt
-bash: abc: command not found
```

再者通过管道查询文件内容是否包含想要的信息：

```cmd
cat test.txt | grep -n 'xxx'
```

上述`cat test.txt`会将`test.txt`的内容作为标准输出，然后利用管道，将其作为`grep -n 'xxx'`命令的标准输入。



### 参考文献

- https://segmentfault.com/a/1190000020519335
- https://murphypei.github.io/blog/2018/04/linux-redirect-pipe
- https://www.huaweicloud.com/articles/0fb70e8c724ae79f4fc8d676cd6160d3.html

# QUESTION：说说你对 shell 的理解？常见的命令？

 ![](https://static.vue-js.com/71003620-0883-11ec-a752-75723a64e8f5.png)


## 一、是什么

 `Shell `是一个由`c`语言编写的应用程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言

它连接了用户和` Linux `内核，让用户能够更加高效、安全、低成本地使用 `Linux` 内核

其本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，它和 QQ、微信等其它软件没有什么区别，特殊的地方就是开机立马启动，并呈现在用户面前

主要作用是接收用户输入的命令，并对命令进行处理，处理完毕后再将结果反馈给用户，比如输出到显示器、写入到文件等，同样能够调用和组织其他的应用程序，相当于一个领导者的身份，如下图：

 ![](https://static.vue-js.com/80db0ca0-0883-11ec-8e64-91fdec0f05a1.png)

那么`shell`脚本就是多个 `Shell` 命令的组合并通过 `if` 条件分支控制或循环来组合运算，实现一些复杂功能，文件后缀名为`.sh`

常用的 `ls` 命令，它本身也是一个 `Shell` 脚本，通过执行这个 `Shell` 脚本可以列举当前目录下的文件列表，如下创建一个`hello.sh`脚本

```shell
#!/bin/bash

# 执行的命令主体
ls
echo "hello world"
```

- #!/bin/bash ：指定脚本要使用的 Shell  类型为 Bash

- ls、echo： 脚本文件的内容，表明我们执行  hello.sh  脚本时会列举出当前目录的文件列表并且会向控制台打印 `hello world

执行方式为`.hello.zsh`



## 二、种类

`Linux` 的 `Shell` 种类众多，只要能给用户提供命令行环境的程序，常见的有：

- Bourne Shell（sh），是目前所有 Shell 的祖先，被安装在几乎所有发源于 Unix 的操作系统上

- Bourne Again shell（bash） ，是 sh 的一个进阶版本，比 sh 更优秀， bash 是目前大多数 Linux 发行版以及 macOS 操作系统的默认 Shell

- C Shell（csh） ，它的语法类似 C 语言

- TENEX C Shell（tcsh） ，它是 csh 的优化版本

- Korn shell（ksh） ，一般在收费的 Unix 版本上比较多见

- Z Shell（zsh） ，它是一种比较新近的 Shell ，集 bash 、 ksh 和 tcsh 各家之大成

![](https://static.vue-js.com/8e739440-0883-11ec-a752-75723a64e8f5.png)

关于 `Shell` 的几个常见命令：

- ls：查看文件
- cd：切换工作目录
- pwd：显示用户当前目录
- mkdir：创建目录
- cp：拷贝
- rm：删除
- mv：移动
- du：显示目录所占用的磁盘空间

## 三、命令

`Shell` 并不是简单的堆砌命令，我们还可以在 `Shell` 中编程，这和使用 `C++`、`C#`、`Java`、`Python` 等常见的编程语言并没有什么两样。

Shell 虽然没有 C++、Java、Python 等强大，但也支持了基本的编程元素，例如：

- if...else 选择结构，case...in 开关语句，for、while、until 循环；
- 变量、数组、字符串、注释、加减乘除、逻辑运算等概念；
- 函数，包括用户自定义的函数和内置函数（例如 printf、export、eval 等）



下面以`bash`为例简单了解一下`shell`的基本使用

### 变量

`Bash` 没有数据类型的概念，所有的变量值都是字符串，可以保存一个数字、一个字符、一个字符串等等

同时无需提前声明变量，给变量赋值会直接创建变量

访问变量的语法形式为：`${var}` 和 `$var` 。

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。

```bash
word="hello"
echo ${word}
# Output: hello
```



### 条件控制

跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在`[[ ]]`里的表达式

跟其他语言一样，使用`if...else`进行表达，如果中括号里的表达式为真，那么`then`和`fi`之间的代码会被执行，如果则`else`和`fi`之间的代码会被执行

```shell
if [[ 2 -ne 1 ]]; then
  echo "true"
else
  echo "false"
fi
# Output: true
```

`fi`标志着条件代码块的结束



### 函数

bash 函数定义语法如下：

```bash
[ function ] funname [()] {
    action;
    [return int;]
}
```

- 函数定义时，function 关键字可有可无
- 函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值
- 函数返回值在调用该函数后通过 $?  来获得
- 所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可

## 参考文献

- http://c.biancheng.net/view/706.html
- https://juejin.cn/post/6930013333454061575


# design
# QUESTION：说说对设计模式的理解？常见的设计模式有哪些？

![](https://static.vue-js.com/065bc170-37ce-11ec-a752-75723a64e8f5.png)



## 一、是什么

在软件工程中，设计模式是对软件设计中普遍存在的各种问题所提出的解决方案

设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案

设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力

因此，当我们遇到合适的场景时，我们可能会条件反射一样自然而然想到符合这种场景的设计模式

比如，当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件

因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题



## 二、有哪些

常见的设计模式有：

- 单例模式
- 工厂模式
- 策略模式
- 代理模式
- 中介者模式
- 装饰者模式
- ......







### 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象

如下图的车，只有一辆，一旦借出去则不能再借给别人：

 ![](https://static.vue-js.com/ea527aa0-37cd-11ec-8e64-91fdec0f05a1.png)





### 工厂模式

工厂模式通常会分成3个角色：

- 工厂角色-负责实现创建所有实例的内部逻辑.
- 抽象产品角色-是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
- 具体产品角色-是创建目标，所有创建的对象都充当这个角色的某个具体类的实例

 ![](https://static.vue-js.com/fadd1920-37cd-11ec-8e64-91fdec0f05a1.png)



### 策略模式

策略模式，就是定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换

至少分成两部分：

- 策略类（可变），策略类封装了具体的算法，并负责具体的计算过程
- 环境类（不变），接受客户的请求，随后将请求委托给某一个策略类







### 代理模式

代理模式：为对象提供一个代用品或占位符，以便控制对它的访问

例如实现图片懒加载的功能，先通过一张`loading`图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到`img`标签里面



### 中介者模式

中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可

通过中介者模式可以解除对象与对象之间的紧耦合关系



### 装饰者模式

装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法

通常运用在原有方法维持不变，在原有方法上再挂载其他方法来满足现有需求



## 三、总结

不断去学习设计模式，会对我们有着极大的帮助，主要如下：

- 从许多优秀的软件系统中总结出的成功的、能够实现可维护性、复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作
- 设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂

- 大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码

- 合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统

- 学习设计模式将有助于初学者更加深入地理解面向对象思想


## 参考文献

- https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)
- https://juejin.cn/post/6844903795017646094
- https://segmentfault.com/a/1190000030850326

# QUESTION：说说你对单例模式的理解？如何实现？

![](https://static.vue-js.com/7df7d830-3b2b-11ec-8e64-91fdec0f05a1.png)



  ## 一、是什么

  单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建

  在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象，如下图所示：

   ![](https://static.vue-js.com/fa7898d0-3b2c-11ec-8e64-91fdec0f05a1.png)

  从定义上来看，全局变量好像就是单例模式，但是一般情况我们不认为全局变量是一个单例模式，原因是：

  - 全局命名污染
  - 不易维护，容易被重写覆盖



  ## 二、实现

在`javascript`中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：

  ```JS
  // 定义一个类
  function Singleton(name) {
      this.name = name;
      this.instance = null;
  }
  // 原型扩展类的一个方法getName()
  Singleton.prototype.getName = function() {
      console.log(this.name)
  };
  // 获取类的实例
  Singleton.getInstance = function(name) {
      if(!this.instance) {
          this.instance = new Singleton(name);
      }
      return this.instance
  };

  // 获取对象1
  const a = Singleton.getInstance('a');
  // 获取对象2
  const b = Singleton.getInstance('b');
  // 进行比较
  console.log(a === b);
  ```

  使用闭包也能够实现，如下：

  ```js
  function Singleton(name) {
      this.name = name;
  }
  // 原型扩展类的一个方法getName()
  Singleton.prototype.getName = function() {
      console.log(this.name)
  };
  // 获取类的实例
  Singleton.getInstance = (function() {
      var instance = null;
      return function(name) {
          if(!this.instance) {
              this.instance = new Singleton(name);
          }
          return this.instance
      }
  })();

  // 获取对象1
  const a = Singleton.getInstance('a');
  // 获取对象2
  const b = Singleton.getInstance('b');
  // 进行比较
  console.log(a === b);
  ```

  也可以将上述的方法稍作修改，变成构造函数的形式，如下：

  ```js
  // 单例构造函数
  function CreateSingleton (name) {
      this.name = name;
      this.getName();
  };

  // 获取实例的名字
  CreateSingleton.prototype.getName = function() {
      console.log(this.name)
  };
  // 单例对象
  const Singleton = (function(){
      var instance;
      return function (name) {
          if(!instance) {
              instance = new CreateSingleton(name);
          }
          return instance;
      }
  })();

  // 创建实例对象1
  const a = new Singleton('a');
  // 创建实例对象2
  const b = new Singleton('b');

  console.log(a===b); // true
  ```



  ## 三、使用场景

  在前端中，很多情况都是用到单例模式，例如页面存在一个模态框的时候，只有用户点击的时候才会创建，而不是加载完成之后再创建弹窗和隐藏，并且保证弹窗全局只有一个

  可以先创建一个通常的获取对象的方法，如下：

  ```js
  const getSingle = function( fn ){
    let result;
    return function(){
      return result || ( result = fn .apply(this, arguments ) );
    }
  };
  ```

  创建弹窗的代码如下：

  ```js
  const createLoginLayer = function(){
    var div = document.createElement( 'div' );
    div.innerHTML = '我是浮窗';
    div.style.display = 'none';
    document.body.appendChild( div );
    return div;
  };

  const createSingleLoginLayer = getSingle( createLoginLayer );

  document.getElementById( 'loginBtn' ).onclick = function(){
    var loginLayer = createSingleLoginLayer();
    loginLayer.style.display = 'block';
  };
  ```

  上述这种实现称为惰性单例，意图解决需要时才创建类实例对象

  并且`Vuex`、`redux`全局态管理库也应用单例模式的思想，如下图：

   ![](https://static.vue-js.com/8be50f80-3b2b-11ec-a752-75723a64e8f5.png)

  现在很多第三方库都是单例模式，多次引用只会使用同一个对象，如`jquery`、`lodash`、`moment`...



  ## 参考文献

  - https://zh.wikipedia.org/zh-hans/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F
  - https://www.runoob.com/design-pattern/singleton-pattern.html
  - https://juejin.cn/post/6844903874210299912#heading-5


# QUESTION：说说你对工厂模式的理解？应用场景？


 ![](https://static.vue-js.com/27a84d10-3bea-11ec-8e64-91fdec0f05a1.png)

## 一、是什么

工厂模式是用来创建对象的一种最常用的设计模式，不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂

其就像工厂一样重复的产生类似的产品，工厂模式只需要我们传入正确的参数，就能生产类似的产品

举个例子：

- 编程中，在一个 A 类中通过 new 的方式实例化了类 B，那么 A 类和 B 类之间就存在关联（耦合）
- 后期因为需要修改了 B 类的代码和使用方式，比如构造函数中传入参数，那么 A 类也要跟着修改，一个类的依赖可能影响不大，但若有多个类依赖了 B 类，那么这个工作量将会相当的大，容易出现修改错误，也会产生很多的重复代码，这无疑是件非常痛苦的事；
- 这种情况下，就需要将创建实例的工作从调用方（A类）中分离，与调用方**解耦**，也就是使用工厂方法创建实例的工作封装起来（**减少代码重复**），由工厂管理对象的创建逻辑，调用方不需要知道具体的创建过程，只管使用，**而降低调用者因为创建逻辑导致的错误**；



## 二、实现

工厂模式根据抽象程度的不同可以分为：

- 简单工厂模式（Simple Factory）
- 工厂方法模式（Factory Method）
- 抽象工厂模式（Abstract Factory）



### 简单工厂模式

简单工厂模式也叫静态工厂模式，用一个工厂对象创建同一类对象类的实例

假设我们要开发一个公司岗位及其工作内容的录入信息，不同岗位的工作内容不一致

代码如下：

```js
function Factory(career) {
    function User(career, work) {
        this.career = career
        this.work = work
    }
    let work
    switch(career) {
        case 'coder':
            work =  ['写代码', '修Bug']
            return new User(career, work)
            break
        case 'hr':
            work = ['招聘', '员工信息管理']
            return new User(career, work)
            break
        case 'driver':
            work = ['开车']
            return new User(career, work)
            break
        case 'boss':
            work = ['喝茶', '开会', '审批文件']
            return new User(career, work)
            break
    }
}
let coder = new Factory('coder')
console.log(coder)
let boss = new Factory('boss')
console.log(boss)
```

`Factory`就是一个简单工厂。当我们调用工厂函数时，只需要传递name、age、career就可以获取到包含用户工作内容的实例对象



### 工厂方法模式

工厂方法模式跟简单工厂模式差不多，但是把具体的产品放到了工厂函数的`prototype`中

这样一来，扩展产品种类就不必修改工厂函数了，和心累就变成抽象类，也可以随时重写某种具体的产品

也就是相当于工厂总部不生产产品了，交给下辖分工厂进行生产；但是进入工厂之前，需要有个判断来验证你要生产的东西是否是属于我们工厂所生产范围，如果是，就丢给下辖工厂来进行生产

如下代码：

```js
// 工厂方法
function Factory(career){
    if(this instanceof Factory){
        var a = new this[career]();
        return a;
    }else{
        return new Factory(career);
    }
}
// 工厂方法函数的原型中设置所有对象的构造函数
Factory.prototype={
    'coder': function(){
        this.careerName = '程序员'
        this.work = ['写代码', '修Bug']
    },
    'hr': function(){
        this.careerName = 'HR'
        this.work = ['招聘', '员工信息管理']
    },
    'driver': function () {
        this.careerName = '司机'
        this.work = ['开车']
    },
    'boss': function(){
        this.careerName = '老板'
        this.work = ['喝茶', '开会', '审批文件']
    }
}
let coder = new Factory('coder')
console.log(coder)
let hr = new Factory('hr')
console.log(hr)
```

工厂方法关键核心代码是工厂里面的判断this是否属于工厂，也就是做了分支判断，这个工厂只做我能做的产品



### 抽象工厂模式

上述简单工厂模式和工厂方法模式都是直接生成实例，但是抽象工厂模式不同，抽象工厂模式并不直接生成实例， 而是用于对产品类簇的创建

通俗点来讲就是：简单工厂和工厂方法模式的工作是生产产品，那么抽象工厂模式的工作就是生产工厂的

由于`JavaScript`中并没有抽象类的概念，只能模拟，可以分成四部分：

- 用于创建抽象类的函数
- 抽象类
- 具体类
- 实例化具体类

上面的例子中有`coder`、`hr`、`boss`、`driver`四种岗位，其中`coder`可能使用不同的开发语言进行开发，比如`JavaScript`、`Java`等等。那么这两种语言就是对应的类簇

示例代码如下：

```js
let CareerAbstractFactory = function(subType, superType) {
  // 判断抽象工厂中是否有该抽象类
  if (typeof CareerAbstractFactory[superType] === 'function') {
    // 缓存类
    function F() {}
    // 继承父类属性和方法
    F.prototype = new CareerAbstractFactory[superType]()
    // 将子类的constructor指向父类
    subType.constructor = subType;
    // 子类原型继承父类
    subType.prototype = new F()
  } else {
    throw new Error('抽象类不存在')
  }
}
```

上面代码中`CareerAbstractFactory`就是一个抽象工厂方法，该方法在参数中传递子类和父类，在方法体内部实现了子类对父类的继承



## 三、应用场景

从上面可看到，简单简单工厂的优点就是我们只要传递正确的参数，就能获得所需的对象，而不需要关心其创建的具体细节

应用场景也容易识别，有构造函数的地方，就应该考虑简单工厂，但是如果函数构建函数太多与复杂，会导致工厂函数变得复杂，所以不适合复杂的情况

抽象工厂模式一般用于严格要求以面向对象思想进行开发的超大型项目中，我们一般常规的开发的话一般就是简单工厂和工厂方法模式会用的比较多一些

综上，工厂模式适用场景如下：

- 如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择
- 将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；
- 需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性



## 参考文献

- https://www.runoob.com/design-pattern/factory-pattern.html
- https://juejin.cn/post/6844903653774458888
- https://zhuanlan.zhihu.com/p/344119981

# QUESTION：说说你对策略模式的理解？应用场景？

 ![](https://static.vue-js.com/e4aad950-3cb2-11ec-8e64-91fdec0f05a1.png)



## 一、是什么

策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来

一个基于策略模式的程序至少由两部分组成：

- 策略类，策略类封装了具体的算法，并负责具体的计算过程
- 环境类Context，Context 接受客户的请求，随后 把请求委托给某一个策略类


## 二、使用

举个例子，公司的年终奖是根据员工的工资和绩效来考核的，绩效为A的人，年终奖为工资的4倍，绩效为B的人，年终奖为工资的3倍，绩效为C的人，年终奖为工资的2倍

若使用`if`来实现，代码则如下：

```js
var calculateBouns = function(salary,level) {
    if(level === 'A') {
        return salary * 4;
    }
    if(level === 'B') {
        return salary * 3;
    }
    if(level === 'C') {
        return salary * 2;
    }
};
// 调用如下：
console.log(calculateBouns(4000,'A')); // 16000
console.log(calculateBouns(2500,'B')); // 7500
```

从上述可有看到，函数内部包含过多`if...else`，并且后续改正的时候，需要在函数内部添加逻辑，违反了开放封闭原则

而如果使用策略模式，就是先定义一系列算法，把它们一个个封装起来，将不变的部分和变化的部分隔开，如下：

```js
var obj = {
        "A": function(salary) {
            return salary * 4;
        },
        "B" : function(salary) {
            return salary * 3;
        },
        "C" : function(salary) {
            return salary * 2;
        }
};
var calculateBouns =function(level,salary) {
    return obj[level](salary);
};
console.log(calculateBouns('A',10000)); // 40000
```

上述代码中，`obj`对应的是策略类，而`calculateBouns`对应上下通信类

又比如实现一个表单校验的代码，常常会像如下写法：

```js
var registerForm = document.getElementById("registerForm");
registerForm.onsubmit = function(){
    if(registerForm.userName.value === '') {
        alert('用户名不能为空');
        return;
    }
    if(registerForm.password.value.length < 6) {
        alert("密码的长度不能小于6位");
        return;
    }
    if(!/(^1[3|5|8][0-9]{9}$)/.test(registerForm.phoneNumber.value)) {
        alert("手机号码格式不正确");
        return;
    }
}
```

上述代码包含多处`if`语句，并且违反了开放封闭原则，如果应用中还有其他的表单，需要重复编写代码

此处也可以使用策略模式进行重构校验，第一步确定不变的内容，即策略规则对象，如下：

```js
var strategy = {
    isNotEmpty: function(value,errorMsg) {
        if(value === '') {
            return errorMsg;
        }
    },
    // 限制最小长度
    minLength: function(value,length,errorMsg) {
        if(value.length < length) {
            return errorMsg;
        }
    },
    // 手机号码格式
    mobileFormat: function(value,errorMsg) {
        if(!/(^1[3|5|8][0-9]{9}$)/.test(value)) {
            return errorMsg;
        }
    }
};
```

然后找出变的地方，作为环境类`context`，负责接收用户的要求并委托给策略规则对象，如下`Validator`类：

```js
var Validator = function(){
        this.cache = [];  // 保存效验规则
};
Validator.prototype.add = function(dom,rule,errorMsg) {
    var str = rule.split(":");
    this.cache.push(function(){
        // str 返回的是 minLength:6
        var strategy = str.shift();
        str.unshift(dom.value); // 把input的value添加进参数列表
        str.push(errorMsg);  // 把errorMsg添加进参数列表
        return strategys[strategy].apply(dom,str);
    });
};
Validator.prototype.start = function(){
    for(var i = 0, validatorFunc; validatorFunc = this.cache[i++]; ) {
        var msg = validatorFunc(); // 开始效验 并取得效验后的返回信息
        if(msg) {
            return msg;
        }
    }
};
```

通过`validator.add`方法添加校验规则和错误信息提示，使用如下：

```js
var validateFunc = function(){
    var validator = new Validator(); // 创建一个Validator对象
    /* 添加一些效验规则 */
    validator.add(registerForm.userName,'isNotEmpty','用户名不能为空');
    validator.add(registerForm.password,'minLength:6','密码长度不能小于6位');
    validator.add(registerForm.userName,'mobileFormat','手机号码格式不正确');

    var errorMsg = validator.start(); // 获得效验结果
    return errorMsg; // 返回效验结果
};
var registerForm = document.getElementById("registerForm");
registerForm.onsubmit = function(){
    var errorMsg = validateFunc();
    if(errorMsg){
        alert(errorMsg);
        return false;
    }
}
```

上述通过策略模式完成表单的验证，并且可以随时调用，在修改表单验证规则的时候，也非常方便，通过传递参数即可调用





## 三、应用场景

从上面可以看到，使用策略模式的优点有如下：

- 策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句
- 策略模式提供了开放-封闭原则，使代码更容易理解和扩展
- 策略模式中的代码可以复用

策略模式不仅仅用来封装算法，在实际开发中，通常会把算法的含义扩散开来，使策略模式也可以用来封装 一系列的“业务规则”

只要这些业务规则指向的目标一致，并且可以被替换使用，我们就可以用策略模式来封装它们



## 参考文献

- https://segmentfault.com/a/1190000021883055
- https://juejin.cn/post/6844903504109109262
- https://juejin.cn/post/6844903751225081864

# QUESTION：说说你对代理模式的理解？应用场景？

 ![](https://static.vue-js.com/899a6ef0-3d6a-11ec-8e64-91fdec0f05a1.png)


## 一、是什么

代理模式（Proxy Pattern）是为一个对象提供一个代用品或占位符，以便控制对它的访问

代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要时，提供一个替身对象来控制这个对象的访问，客户实际上访问的是替身对象

 ![](https://static.vue-js.com/951c99b0-3d6a-11ec-a752-75723a64e8f5.png)

在生活中，代理模式的场景是十分常见的，例如我们现在如果有租房、买房的需求，更多的是去找链家等房屋中介机构，而不是直接寻找想卖房或出租房的人谈。此时，链家起到的作用就是代理的作用


## 二、使用

在`ES6`中，存在`proxy`构建函数能够让我们轻松使用代理模式：

```js
const proxy = new Proxy(target, handler);
```

关于`Proxy`的使用可以翻看以前的文章

而按照功能来划分，`javascript`代理模式常用的有：

- 缓存代理

- 虚拟代理



### 缓存代理

缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果

如实现一个求积乘的函数，如下：

```js
var muti = function () {
  console.log("开始计算乘积");
  var a = 1;
  for (var i = 0, l = arguments.length; i < l; i++) {
    a = a * arguments[i];
  }
  return a;
};
```

现在加入缓存代理，如下：

```js
var proxyMult = (function () {
  var cache = {};
  return function () {
    var args = Array.prototype.join.call(arguments, ",");
    if (args in cache) {
      return cache[args];
    }
    return (cache[args] = mult.apply(this, arguments));
  };
})();

proxyMult(1, 2, 3, 4); // 输出:24
proxyMult(1, 2, 3, 4); // 输出:24
```

当第二次调用 `proxyMult(1, 2, 3, 4)` 时，本体 `mult` 函数并没有被计算，`proxyMult` 直接返回了之前缓存好的计算结果





### 虚拟代理

虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建

常见的就是图片预加载功能：

未使用代理模式如下：

```js
let MyImage = (function(){
    let imgNode = document.createElement( 'img' );
    document.body.appendChild( imgNode );
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;

    img.onload = function(){
        // 监听到图片加载完成后，设置src为加载完成后的图片
        imgNode.src = img.src;
    };

    return {
        setSrc: function( src ){
            // 设置图片的时候，设置为默认的loading图
            imgNode.src = 'https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif';
            // 把真正需要设置的图片传给Image对象的src属性
            img.src = src;
        }
    }
})();

MyImage.setSrc( 'https://xxx.jpg' );
```

`MyImage`对象除了负责给`img`节点设置`src`外，还要负责预加载图片，违反了面向对象设计的原则——单一职责原则

上述过程`loding`则是耦合进`MyImage`对象里的，如果以后某个时候，我们不需要预加载显示loading这个功能了，就只能在`MyImage`对象里面改动代码

使用代理模式，代码则如下：

```js
// 图片本地对象，负责往页面中创建一个img标签，并且提供一个对外的setSrc接口
let myImage = (function(){
    let imgNode = document.createElement( 'img' );
    document.body.appendChild( imgNode );

    return {
        //setSrc接口，外界调用这个接口，便可以给该img标签设置src属性
        setSrc: function( src ){
            imgNode.src = src;
        }
    }
})();
// 代理对象，负责图片预加载功能
let proxyImage = (function(){
    // 创建一个Image对象，用于加载需要设置的图片
    let img = new Image;
    img.onload = function(){
        // 监听到图片加载完成后，给被代理的图片本地对象设置src为加载完成后的图片
        myImage.setSrc( this.src );
    }
    return {
        setSrc: function( src ){
            // 设置图片时，在图片未被真正加载好时，以这张图作为loading，提示用户图片正在加载
            myImage.setSrc( 'https://img.zcool.cn/community/01deed576019060000018c1bd2352d.gif' );
            img.src = src;
        }
    }
})();

proxyImage.setSrc( 'https://xxx.jpg' );
```

使用代理模式后，图片本地对象负责往页面中创建一个`img`标签，并且提供一个对外的`setSrc`接口；

代理对象负责在图片未加载完成之前，引入预加载的`loading`图，负责了图片预加载的功能

上述并没有改变或者增加`MyImage`的接口，但是通过代理对象，实际上给系统添加了新的行为

并且上述代理模式可以发现，代理和本体接口的一致性，如果有一天不需要预加载，那么就不需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 `setSrc` 方法

‘

## 三、应用场景

现在的很多前端框架或者状态管理框架都使用代理模式，用与监听变量的变化

使用代理模式代理对象的访问的方式，一般又被称为拦截器，比如我们在项目中经常使用 `Axios` 的实例来进行 HTTP 的请求，使用拦截器 `interceptor` 可以提前对 请求前的数据 服务器返回的数据进行一些预处理

以及上述应用到的缓存代理和虚拟代理


## 参考文献

- https://juejin.cn/post/6844903555036364814#heading-2
- https://juejin.cn/post/6992510837403418654#heading-7
- https://sothx.com/2021/06/26/proxy/

# QUESTION：说说你对发布订阅、观察者模式的理解？区别？

 ![](https://static.vue-js.com/342739f0-3fb1-11ec-8e64-91fdec0f05a1.png)


## 一、观察者模式

观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新

观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯

 ![](https://static.vue-js.com/d3a80020-3f7c-11ec-a752-75723a64e8f5.png)

例如生活中，我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸

报社和订报纸的客户就形成了一对多的依赖关系

实现代码如下：

被观察者模式

```js
class Subject {

  constructor() {
    this.observerList = [];
  }

  addObserver(observer) {
    this.observerList.push(observer);
  }

  removeObserver(observer) {
    const index = this.observerList.findIndex(o => o.name === observer.name);
    this.observerList.splice(index, 1);
  }

  notifyObservers(message) {
    const observers = this.observeList;
    observers.forEach(observer => observer.notified(message));
  }

}
```

观察者：

```h'
class Observer {

  constructor(name, subject) {
    this.name = name;
    if (subject) {
      subject.addObserver(this);
    }
  }

  notified(message) {
    console.log(this.name, 'got message', message);
  }
}
```

使用代码如下：

```js
const subject = new Subject();
const observerA = new Observer('observerA', subject);
const observerB = new Observer('observerB');
subject.addObserver(observerB);
subject.notifyObservers('Hello from subject');
subject.removeObserver(observerA);
subject.notifyObservers('Hello again');
```

上述代码中，观察者主动申请加入被观察者的列表，被观察者主动将观察者加入列表





## 二、发布订阅模式

发布-订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在

同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在

![](https://static.vue-js.com/e24d3cd0-3f7c-11ec-8e64-91fdec0f05a1.png)



实现代码如下：

```js
class PubSub {
  constructor() {
    this.messages = {};
    this.listeners = {};
  }
  // 添加发布者
  publish(type, content) {
    const existContent = this.messages[type];
    if (!existContent) {
      this.messages[type] = [];
    }
    this.messages[type].push(content);
  }
  // 添加订阅者
  subscribe(type, cb) {
    const existListener = this.listeners[type];
    if (!existListener) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(cb);
  }
  // 通知
  notify(type) {
    const messages = this.messages[type];
    const subscribers = this.listeners[type] || [];
    subscribers.forEach((cb, index) => cb(messages[index]));
  }
}
```

发布者代码如下：

```js
class Publisher {
  constructor(name, context) {
    this.name = name;
    this.context = context;
  }
  publish(type, content) {
    this.context.publish(type, content);
  }
}
```

订阅者代码如下：

```js
class Subscriber {
  constructor(name, context) {
    this.name = name;
    this.context = context;
  }
  subscribe(type, cb) {
    this.context.subscribe(type, cb);
  }
}
```

使用代码如下：

```js
const TYPE_A = 'music';
const TYPE_B = 'movie';
const TYPE_C = 'novel';

const pubsub = new PubSub();

const publisherA = new Publisher('publisherA', pubsub);
publisherA.publish(TYPE_A, 'we are young');
publisherA.publish(TYPE_B, 'the silicon valley');
const publisherB = new Publisher('publisherB', pubsub);
publisherB.publish(TYPE_A, 'stronger');
const publisherC = new Publisher('publisherC', pubsub);
publisherC.publish(TYPE_C, 'a brief history of time');

const subscriberA = new Subscriber('subscriberA', pubsub);
subscriberA.subscribe(TYPE_A, res => {
  console.log('subscriberA received', res)
});
const subscriberB = new Subscriber('subscriberB', pubsub);
subscriberB.subscribe(TYPE_C, res => {
  console.log('subscriberB received', res)
});
const subscriberC = new Subscriber('subscriberC', pubsub);
subscriberC.subscribe(TYPE_B, res => {
  console.log('subscriberC received', res)
});

pubsub.notify(TYPE_A);
pubsub.notify(TYPE_B);
pubsub.notify(TYPE_C);
```

上述代码，发布者和订阅者需要通过发布订阅中心进行关联，发布者的发布动作和订阅者的订阅动作相互独立，无需关注对方，消息派发由发布订阅中心负责





## 三、区别

两种设计模式思路是一样的，举个生活例子：

- 观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体
- 发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决

上述过程中，如果公司自己去管理快递的配送，那公司就会变成一个快递公司，业务繁杂难以管理，影响公司自身的主营业务，因此使用何种模式需要考虑什么情况两者是需要耦合的

两者区别如下图：

![](https://files.mdnice.com/user/155/9141682c-7386-4f12-8412-fb17a1cd4bf6.png)

- 在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。

- 在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。

- 观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）



## 参考文献

- https://zh.wikipedia.org/zh-hans/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F
- https://zh.wikipedia.org/wiki/%E5%8F%91%E5%B8%83/%E8%AE%A2%E9%98%85
- https://www.cnblogs.com/onepixel/p/10806891.html
- https://juejin.cn/post/6978728619782701087